<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDCo HLSF Engine Visualizer (Web)</title>
  <style>
    :root { --bg:#0b0b0b; --panel:#121212; --ink:#e9e9e9; --muted:#a5a5a5; --accent:#6cf; --btn:#1c1c1c; --btn-h:#242424; --border:#2a2a2a; }
    :root {
      --btn-fg:#e9e9e9; --btn-bg:#1c1c1c; --btn-bg-h:#242424; --btn-bd:#2a2a2a;
      --primary:#3aa5ff; --primary-h:#2e83cc; --primary-bd:#1f5e91;
      --success:#22c55e; --success-h:#19924a; --success-bd:#116d37;
      --warning:#f59e0b; --warning-h:#c47c09; --warning-bd:#8f5b06;
      --danger:#ef4444; --danger-h:#c03636; --danger-bd:#8f2828;
      --neutral:#374151; --neutral-h:#4b5563; --neutral-bd:#1f2937;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";}
    .app{display:grid;grid-template-rows:auto auto minmax(0,1fr) auto;height:100%}
    @supports(height:100dvh){.app{height:100dvh}}
    header,footer{padding:10px 14px;background:var(--panel);border-bottom:1px solid var(--border)}
    footer{border-top:1px solid var(--border);border-bottom:none;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .controls{display:flex;flex-direction:column;gap:10px;padding:8px 12px;background:var(--panel);border-bottom:1px solid var(--border)}
    .tab-bar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .tab-btn{background:#111;border:1px solid var(--border);color:var(--muted);border-radius:999px;padding:6px 14px;cursor:pointer;font-weight:600;letter-spacing:.2px}
    .tab-btn[aria-selected="true"]{background:var(--btn-bg);color:var(--ink);border-color:var(--accent);box-shadow:0 0 0 1px rgba(108,204,255,0.25) inset}
    .tab-panels{display:grid}
    .tab-panel{display:none;grid-template-columns:repeat(12,minmax(0,1fr));gap:10px}
    .tab-panel.active{display:grid}
    .mode-indicator{margin-left:auto;font-size:12px;color:var(--muted);letter-spacing:.3px;text-transform:uppercase}
    .group{border:1px solid var(--border);border-radius:12px;padding:10px;background:#0f0f0f}
    .group h3{margin:0 0 8px;font-size:13px;color:var(--muted);font-weight:600;letter-spacing:.3px;text-transform:uppercase}
    .row{display:flex;flex-wrap:wrap;gap:6px;align-items:center}
    input[type="number"],input[type="text"]{background:#111;color:var(--ink);border:1px solid var(--border);border-radius:8px;padding:7px 9px;width:90px;text-align:center}
    button{background:var(--btn-bg);color:var(--btn-fg);border:1px solid var(--btn-bd);border-radius:8px;padding:7px 10px;cursor:pointer;white-space:nowrap;transition:background .15s ease,border-color .15s ease,transform .03s ease}
    button:hover{background:var(--btn-bg-h)} button:active{transform:translateY(1px)} button:disabled{opacity:.55;cursor:not-allowed}
    .btn-primary{background:var(--primary);border-color:var(--primary-bd);color:#0b0b0b}.btn-primary:hover{background:var(--primary-h)}
    .btn-success{background:var(--success);border-color:var(--success-bd);color:#0b0b0b}.btn-success:hover{background:var(--success-h)}
    .btn-warning{background:var(--warning);border-color:var(--warning-bd);color:#0b0b0b}.btn-warning:hover{background:var(--warning-h)}
    .btn-danger{background:var(--danger);border-color:var(--danger-bd);color:#0b0b0b}.btn-danger:hover{background:var(--danger-h)}
    .btn-neutral{background:var(--neutral);border-color:var(--neutral-bd);color:#e9e9e9}.btn-neutral:hover{background:var(--neutral-h)}
    [aria-pressed="true"].btn-primary,[aria-pressed="true"].btn-success,[aria-pressed="true"].btn-warning,[aria-pressed="true"].btn-danger,[aria-pressed="true"].btn-neutral{filter:saturate(1.1) brightness(.95);box-shadow:inset 0 0 0 9999px rgba(0,0,0,.08)}
    .levels{display:flex;flex-wrap:wrap;gap:6px}.lvl-btn{min-width:32px;text-align:center}.lvl-btn.active{outline:2px solid var(--accent)}
    .code-label{font-family:ui-monospace,Menlo,Consolas,"SF Mono","Roboto Mono",monospace;font-size:13px;color:var(--accent);padding:4px 8px;background:#0f0f0f;border-radius:8px;border:1px solid var(--border);max-width:100%;overflow:hidden;text-overflow:ellipsis}
    .code-stack{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .meta-details{position:relative}
    .meta-details summary{list-style:none;cursor:pointer;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.3px}
    .meta-details summary::-webkit-details-marker{display:none}
    .meta-popover{position:absolute;right:0;top:calc(100% + 6px);min-width:220px;background:#0f0f0f;border:1px solid var(--border);border-radius:10px;padding:10px;z-index:2;box-shadow:0 10px 30px rgba(0,0,0,0.35)}
    .meta-popover .code-label{display:block;margin-bottom:6px}
    .guide{padding:10px 14px;background:var(--panel);border-bottom:1px solid var(--border)}
    .guide details{background:#0f0f0f;border:1px solid var(--border);border-radius:12px;padding:10px 12px}
    .guide summary{cursor:pointer;font-weight:600;color:var(--ink);letter-spacing:.2px}
    .guide summary span{color:var(--muted);font-weight:500;margin-left:6px}
    .guide h4{margin:12px 0 6px;font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.3px}
    .guide ul{margin:6px 0 10px;padding-left:18px;color:var(--ink)}
    .guide li{margin:4px 0}
    .guide code{font-family:ui-monospace,Menlo,Consolas,"SF Mono","Roboto Mono",monospace;font-size:12px;color:var(--accent)}
    .guide .note{color:var(--muted);font-size:12px}
    .main{display:grid;grid-template-columns:minmax(0,1fr) minmax(320px,40%);gap:12px;min-height:0;padding:0 12px 12px;transition:grid-template-columns .2s ease}
    body.audio-mode .main{grid-template-columns:minmax(0,1fr) minmax(360px,46%)}
    .main.spec-hidden{grid-template-columns:minmax(0,1fr)}
    .panel{background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;min-height:0;border-radius:16px 0 0 16px}
    .spectrogram{min-width:320px;max-width:65vw;resize:horizontal;overflow:auto;background:#070a12}
    .spec-header{padding:12px;border-bottom:1px solid var(--border);background:#0b0f1a}
    .spec-controls{display:flex;flex-direction:column;gap:8px}
    .spec-row{display:flex;flex-wrap:wrap;gap:6px;align-items:center}
    .spec-body{position:relative;flex:1;min-height:0;background:radial-gradient(circle at top left, rgba(108,204,255,0.08), transparent 45%),#05060a}
    .spec-body canvas{width:100%;height:100%}
    .spec-readout{position:absolute;left:10px;bottom:8px;font-size:12px;color:var(--muted);background:rgba(0,0,0,0.55);padding:4px 8px;border-radius:8px;border:1px solid var(--border)}
    .spec-meta{font-size:12px;color:var(--muted)}
    .spec-hidden #specPanel{display:none;}
    .canvas-wrap{position:relative;background:#000;min-height:0} canvas{display:block;width:100%;height:100%}
    .canvas-wrap::after{content:"";position:absolute;inset:0;pointer-events:none;background:
      radial-gradient(circle at center, rgba(108,204,255,0.35) 0 1px, transparent 1px),
      linear-gradient(to right, transparent 49.8%, rgba(108,204,255,0.12) 49.8%, rgba(108,204,255,0.12) 50.2%, transparent 50.2%),
      linear-gradient(to bottom, transparent 49.8%, rgba(108,204,255,0.12) 49.8%, rgba(108,204,255,0.12) 50.2%, transparent 50.2%);
      opacity:0.35}
    .help{color:var(--muted)} .status{color:var(--muted)}
    .entity-label{font-size:12px;color:var(--muted)}
    body.focus-mode header,
    body.focus-mode .controls,
    body.focus-mode .guide,
    body.focus-mode footer{opacity:0.4;transition:opacity .2s ease}
    [data-focus-lock="true"]{transition:opacity .2s ease}
    body.focus-mode [data-focus-lock="true"]{opacity:0.35;pointer-events:none}
    @media (max-width:1100px){
      .main{grid-template-columns:minmax(0,1fr);grid-template-rows:minmax(0,1fr) minmax(260px,38vh)}
      body.audio-mode .main{grid-template-rows:minmax(0,1fr) minmax(320px,45vh)}
      .panel{border-left:none;border-top:1px solid var(--border);border-radius:16px 16px 0 0}
      .spectrogram{max-width:none;min-width:0;resize:none}
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
      <div><strong>PDCo HLSF Engine Visualizer</strong> — Web Port</div>
      <div class="code-stack">
        <div class="code-label" id="codeLabel">—</div>
        <details class="meta-details">
          <summary>Diagnostics</summary>
          <div class="meta-popover">
            <div class="code-label" id="graphStats">nodes: — | adj: —</div>
          </div>
        </details>
      </div>
    </div>
  </header>

  <div class="controls">
    <div class="tab-bar">
      <button class="tab-btn" data-tab="geometry" aria-selected="true">Geometry</button>
      <button class="tab-btn" data-tab="motion" aria-selected="false">Motion</button>
      <button class="tab-btn" data-tab="audio" aria-selected="false">Audio</button>
      <button class="tab-btn" data-tab="view" aria-selected="false">View</button>
      <div class="mode-indicator" id="modeIndicator">Mode: Explore</div>
    </div>
    <div class="tab-panels">
      <div class="tab-panel active" id="tab-geometry" data-tab-panel="geometry">
        <div class="group" style="grid-column: span 6;" data-focus-lock="true">
          <h3>Dimension & Level</h3>
          <div class="row">
            <label for="sidesInput">n (sides):</label>
            <input id="sidesInput" type="number" min="4" step="1" value="12" />
            <button id="nMinus">n −1</button>
            <button id="nPlus">n +1</button>
            <button id="updatePlot">Update Plot</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <span>Level:</span>
            <div class="levels" id="levelButtons"></div>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="cancelGen">Cancel Generation</button>
          </div>
        </div>
        <div class="group" style="grid-column: span 6;" data-focus-lock="true">
          <h3>Appearance</h3>
          <div class="row">
            <label for="alphaInput">Alpha (α):</label>
            <input id="alphaInput" type="number" min="0" max="1" step="0.0001" value="0.02" />
            <button id="applyAlpha">Apply α</button>
            <button id="autoAlpha">Auto α</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <span>Overlayed α:</span>
            <span id="overlayAlpha">—</span>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="toggleEdges" class="btn-neutral">Show Colors</button>
            <button id="colorMode" class="btn-neutral">Color Mode</button>
            <button id="toggleBg" class="btn-neutral" aria-pressed="true">BG: White</button>
          </div>
        </div>
      </div>

      <div class="tab-panel" id="tab-motion" data-tab-panel="motion">
        <div class="group" style="grid-column: span 12;" data-focus-lock="true">
          <h3>Rotation</h3>
          <div class="row" style="margin-bottom:8px;">
            <label for="speedInput">Speed:</label>
            <input id="speedInput" type="number" min="0.001" max="10" step="0.001" value="0.50" />
          </div>
          <div class="row">
            <button id="speedPlus">Speed +</button>
            <button id="speedMinus">Speed −</button>
            <button id="toggleRotation" class="btn-primary">Start Rotation</button>
            <button id="toggleEmergent" class="btn-success">Emergent Rotation</button>
            <button id="pauseEmergent" class="btn-warning" disabled>Pause Emergent</button>
            <button id="stepBack" class="btn-neutral" title="Step Back (,) " disabled>Step ◀</button>
            <button id="stepForward" class="btn-neutral" title="Step Forward (.)" disabled>Step ▶</button>
            <button id="toggleSnap" class="btn-neutral" aria-pressed="false">
              Snap: OFF
            </button>
          </div>
        </div>
      </div>

      <div class="tab-panel" id="tab-audio" data-tab-panel="audio">
        <div class="group" style="grid-column: span 6;" data-focus-lock="true">
          <h3>Audio Focus</h3>
          <div class="row">
            <button id="toggleAudio" class="btn-success" aria-pressed="false">Audio: Off</button>
            <button id="toggleLiveFft" class="btn-neutral" aria-pressed="false">Live FFT: Off</button>
            <button id="cycleLiveEntity" class="btn-neutral">Live Entity +</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <span class="status" id="audioStatus">Audio muted</span>
          </div>
        </div>
        <div class="group" style="grid-column: span 6;" data-focus-lock="true">
          <h3>Audio Guidance</h3>
          <div class="row">
            <span class="status">Enable audio to expand the spectrogram and surface FFT controls.</span>
          </div>
        </div>
      </div>

      <div class="tab-panel" id="tab-view" data-tab-panel="view">
        <div class="group" style="grid-column: span 6;" data-focus-lock="true">
          <h3>Navigate</h3>
          <div class="row">
            <button id="zoomIn">Zoom In</button>
            <button id="zoomOut">Zoom Out</button>
            <button id="resetView">Reset View</button>
            <button id="viewPortal">View Portal</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="panLeft">◀️</button>
            <button id="panRight">▶️</button>
            <button id="panUp">▲</button>
            <button id="panDown">▼</button>
            <button id="downloadPng" type="button" style="margin-left:auto;"></button>
          </div>
        </div>
        <div class="group" style="grid-column: span 6;">
          <h3>Entity Focus</h3>
          <div class="row">
            <button id="entityPrev">Entity ◀</button>
            <button id="entityNext">Entity ▶</button>
            <button id="entityAuto" class="btn-neutral" aria-pressed="false">Auto-Advance</button>
            <button id="entityLock" class="btn-neutral" aria-pressed="false">Lock Rotation</button>
            <button id="exitFocus" class="btn-neutral">Exit Focus</button>
          </div>
          <div class="row" style="margin-top:8px;">
            <span class="entity-label" id="entityLabel">Entity —</span>
          </div>
        </div>
      </div>
    </div>
    <input id="specFileInput" type="file" accept="application/json" style="display:none" />
  </div>

  <section class="guide" aria-label="Ridge tuning guide">
    <details>
      <summary>Ridge Tuning Guide <span>What to change, why it matters</span></summary>
      <h4>1) Ridge selectivity (Top-K)</h4>
      <ul>
        <li><code>this._ridgeTopK = 2</code> → very tonal, sparse</li>
        <li><code>this._ridgeTopK = 3</code> → balanced (recommended)</li>
        <li><code>this._ridgeTopK = 5</code> → dense, chord-like</li>
      </ul>
      <div class="note">Rule: low sides / low levels → smaller K. High sides / emergent rotation → larger K.</div>

      <h4>2) Persistence (decay)</h4>
      <ul>
        <li><code>this._ridgeDecay = 0.90</code> → fast fade (percussive)</li>
        <li><code>this._ridgeDecay = 0.94</code> → musical sustain</li>
        <li><code>this._ridgeDecay = 0.97</code> → drone / structural memory</li>
      </ul>
      <div class="note">Interpretation: &lt; 0.9 = noisy, 0.97 = everything sticks forever. Sweet spot: 0.92–0.95.</div>

      <h4>3) Reinforcement strength</h4>
      <ul>
        <li><code>this._ridgeBoost = 0.25</code> → conservative</li>
        <li><code>this._ridgeBoost = 0.35</code> → default</li>
        <li><code>this._ridgeBoost = 0.50</code> → aggressive locking</li>
      </ul>
      <div class="note">If ridges “snap” too hard → lower boost. If ridges never form → raise boost.</div>

      <h4>4) Optional: frequency-weighted bias (recommended)</h4>
      <p class="note">Higher ω bins are noisier. Bias against them so low/mid harmonics dominate naturally.</p>
      <pre class="code-label">const weight = 1 - (bin / mag.length);
this._ridgeHold.set(
  bin,
  Math.min(1, cur + val * weight * this._ridgeBoost)
);</pre>

      <h4>5) Visual encoding (small but important)</h4>
      <p class="note">Instead of pure white, use blue-white ridges for dark mode:</p>
      <pre class="code-label">ctx.strokeStyle = this.whiteBg
  ? `rgba(0,0,0,${alpha})`
  : `rgba(180,220,255,${alpha})`;</pre>
    </details>
  </section>

  <div class="main" id="mainPanel">
  <div class="canvas-wrap" id="canvasWrap"><canvas id="canvas" tabindex="0"></canvas></div>
    <div id="specPanel" class="panel spectrogram">
      <div class="spec-header">
        <div class="spec-controls">
          <div class="spec-row">
            <strong>Spectrogram</strong>
            <span class="spec-meta" id="specInfo">No session loaded</span>
            <button id="toggleSpecPanel" class="btn-neutral" style="margin-left:auto;">Hide Panel</button>
          </div>
          <div class="spec-row">
            <button id="specViewOmegaLevel" class="btn-primary" aria-pressed="true">ω–L</button>
            <button id="specViewOmegaTime" class="btn-neutral" aria-pressed="false">ω–t</button>
            <button id="specViewLevelTime" class="btn-neutral" aria-pressed="false">L–t</button>
          </div>
          <div class="spec-row">
            <button id="specZoomOmegaIn">Zoom ω +</button>
            <button id="specZoomOmegaOut">Zoom ω −</button>
            <button id="specZoomLevelIn">Zoom L +</button>
            <button id="specZoomLevelOut">Zoom L −</button>
            <button id="specZoomReset" class="btn-neutral">Reset Zoom</button>
          </div>
          <div class="spec-row">
            <button id="exportSpec" class="btn-neutral">Export Session</button>
            <button id="importSpec" class="btn-neutral">Import Session</button>
            <button id="replaySpec" class="btn-warning">Replay Session</button>
          </div>
          <div class="spec-row">
            <label for="sliceBinInput">ω bin:</label>
            <input id="sliceBinInput" type="number" min="1" step="1" value="6" />
            <button id="toggleCubeSlice" class="btn-neutral" aria-pressed="true">L×t Slice</button>
          </div>
        </div>
      </div>
      <div class="spec-body">
        <canvas id="specCanvas" width="1024" height="512"></canvas>
        <div class="spec-readout" id="specReadout">ω — | L — | val —</div>
      </div>
      <canvas id="waveCanvas" style="width:100%;height:140px;"></canvas>
    </div>
  </div>

  <footer>
    <div class="status" id="status">Ready</div>
    <div class="help">Mouse: drag to pan, wheel to zoom. Keys: arrows, <strong>r</strong> reset, <strong>e</strong> export, <strong>i</strong> import, <strong>p</strong> replay, <strong>,</strong>/<strong>.</strong> step Emergent.</div>
  </footer>
</div>

<script>
(()=> {
  const TAU=Math.PI*2, clamp=(v,a,b)=>Math.min(b,Math.max(a,v)), canonicalStartAngle=(n)=> (n%2 ? Math.PI/2 : 0);

  function hsvToRgb(h,s,v){let r=0,g=0,b=0,i=Math.floor(h*6),f=h*6-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s);switch(i%6){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;case 5:r=v;g=p;b=q;break}return[Math.round(r*255),Math.round(g*255),Math.round(b*255)]}
  const rgbaStr=(r,g,b,a)=>`rgba(${r},${g},${b},${a})`;
  function buildHsvPalette(n,s=.85,v=.95){const out=[],count=Math.max(1,n|0);for(let i=0;i<count;i++){const [r,g,b]=hsvToRgb(i/count,s,v);out.push([r,g,b,1])}return out}
  const _specRampStops=[
    [0.0,[8,12,28]],
    [0.22,[28,42,98]],
    [0.5,[44,110,168]],
    [0.72,[76,183,136]],
    [1.0,[245,243,153]]
  ];
  function _specColorRgb(v){
    const t=clamp(v,0,1);
    for(let i=1;i<_specRampStops.length;i++){
      const [p1,c1]=_specRampStops[i-1];
      const [p2,c2]=_specRampStops[i];
      if(t<=p2){
        const u=(t-p1)/(p2-p1||1);
        const r=Math.round(c1[0]+(c2[0]-c1[0])*u);
        const g=Math.round(c1[1]+(c2[1]-c1[1])*u);
        const b=Math.round(c1[2]+(c2[2]-c1[2])*u);
        return [r,g,b];
      }
    }
    return [245,243,153];
  }
  function _specColor(v){
    const [r,g,b]=_specColorRgb(v);
    return `rgb(${r},${g},${b})`;
  }
  const DB_FLOOR=-80;
  const DB_CEIL=0;
  const DB_EPS=1e-6;
  const magToDb=(mag)=>20*Math.log10(mag+DB_EPS);
  const dbToNorm=(db)=>clamp((db-DB_FLOOR)/(DB_CEIL-DB_FLOOR),0,1);

  function polygonVertices(center,radius,sides){
    const [cx,cy]=center, start=canonicalStartAngle(sides), arr=[];
    for(let i=0;i<sides;i++){const a=start+i*TAU/sides;arr.push([cx+radius*Math.cos(a),cy+radius*Math.sin(a)])}
    return arr;
  }

  const multiplier=(level,sides)=>(sides%2===0)?Math.pow(2,level-2):Math.pow(1.5,level-2);

  function calculateSymmetryPointAdjusted(center,radius,sides,level){
    const [cx,cy]=center; if(level<=1) return [cx,cy,0];
    const base=canonicalStartAngle(sides), half=(sides%2===1)?(Math.PI/sides):0, ang=base+half;
    const rf=(sides%2===1)?Math.cos(Math.PI/sides):1;
    let dist=0; for(let cur=2;cur<=level;cur++) dist+=radius*multiplier(cur,sides)*rf;
    return [cx+Math.cos(ang)*dist, cy+Math.sin(ang)*dist, 0];
  }

  function buildBaseTriangles(vertices,sides){
    const tris=[], limit=(sides%2)?(Math.floor(sides/2)+2):(Math.floor(sides/2)+1), i=0;
    for(let j=2;j<limit;j++){const a=vertices[i], b=vertices[(i+j)%sides], c=vertices[(i+j-1)%sides]; tris.push([a,b,c])}
    return tris;
  }

  function rotatePointAround(p,pivot,th){const[px,py]=p,[cx,cy]=pivot,dx=px-cx,dy=py-cy,ct=Math.cos(th),st=Math.sin(th);return[ct*dx-st*dy+cx,st*dx+ct*dy+cy]}
  function rotateTrianglesAround(tris,pivot,th){const out=new Array(tris.length);for(let t=0;t<tris.length;t++){const tri=tris[t];out[t]=[rotatePointAround(tri[0],pivot,th),rotatePointAround(tri[1],pivot,th),rotatePointAround(tri[2],pivot,th)]}return out}
  function trianglesCenters(tris){const c=new Array(tris.length);for(let i=0;i<tris.length;i++){const[a,b,d]=tris[i];c[i]=[(a[0]+b[0]+d[0])/3,(a[1]+b[1]+d[1])/3]}return c}
  function polygonArea(poly){
    let area=0;
    for(let i=0;i<poly.length;i++){
      const [x1,y1]=poly[i];
      const [x2,y2]=poly[(i+1)%poly.length];
      area+=x1*y2-x2*y1;
    }
    return Math.abs(area)/2;
  }
  function clipPolygonToRect(poly,[xmin,ymin,xmax,ymax]){
    const edges=[
      {inside:([x,y])=>x>=xmin, intersect:(a,b)=>[xmin, a[1]+(b[1]-a[1])*(xmin-a[0])/(b[0]-a[0]||1e-9)]},
      {inside:([x,y])=>x<=xmax, intersect:(a,b)=>[xmax, a[1]+(b[1]-a[1])*(xmax-a[0])/(b[0]-a[0]||1e-9)]},
      {inside:([x,y])=>y>=ymin, intersect:(a,b)=>[a[0]+(b[0]-a[0])*(ymin-a[1])/(b[1]-a[1]||1e-9), ymin]},
      {inside:([x,y])=>y<=ymax, intersect:(a,b)=>[a[0]+(b[0]-a[0])*(ymax-a[1])/(b[1]-a[1]||1e-9), ymax]}
    ];
    let output=poly;
    for(const edge of edges){
      const input=output;
      output=[];
      if(!input.length) break;
      let S=input[input.length-1];
      for(const E of input){
        const Ein=edge.inside(E);
        const Sin=edge.inside(S);
        if(Ein){
          if(!Sin) output.push(edge.intersect(S,E));
          output.push(E);
        } else if(Sin){
          output.push(edge.intersect(S,E));
        }
        S=E;
      }
    }
    return output;
  }
  function triangleIntersectsRect(tri,rect){
    const clipped=clipPolygonToRect(tri,rect);
    return clipped.length>=3&&polygonArea(clipped)>0;
  }
  function triangleVisibleFraction(tri,rect){
    const area=polygonArea(tri);
    if(!(area>0)) return 0;
    const clipped=clipPolygonToRect(tri,rect);
    if(clipped.length<3) return 0;
    return polygonArea(clipped)/area;
  }
  function totalReplications(sides,levels){if(levels<=0)return 0;if(sides===1)return levels;return Math.floor((sides*(Math.pow(sides,levels)-1))/(sides-1))}

  class HLSFGenerator{
    constructor(center=[0,0],radius=1,sides=8,levels=2){
      this.center=center.slice(); this.radius=radius; this.sides=sides; this.levels=levels;
      this.vertices=polygonVertices(this.center,this.radius,this.sides);
      this.level_seed_tris={}; this.level_tris={}; this.level_seed_centers={}; this.level_symmetry={};
      this.computeLevels();
    }
    setSides(n){this.sides=n; this.vertices=polygonVertices(this.center,this.radius,this.sides)}
    setLevels(L){this.levels=L}
    computeLevels(opts={}){
      const deferAtLevel=opts.deferAtLevel??null;
      this.vertices=polygonVertices(this.center,this.radius,this.sides);
      const baseTris=buildBaseTriangles(this.vertices,this.sides);
      this.level_seed_tris={}; this.level_tris={}; this.level_seed_centers={}; this.level_symmetry={};
      this.level_seed_tris[0]=baseTris.map(t=>t.map(p=>p.slice()));
      this.level_seed_centers[0]=trianglesCenters(this.level_seed_tris[0]);
      this.level_tris[0]=baseTris.map(t=>t.map(p=>p.slice()));
      let current=[];
      if(this.level_seed_tris[0].length){for(let i=0;i<this.sides;i++){const ang=(TAU/this.sides)*i; current=current.concat(rotateTrianglesAround(this.level_seed_tris[0],this.center,ang))}}
      this.level_seed_tris[1]=this.level_tris[0].map(t=>t.map(p=>p.slice()));
      this.level_seed_centers[1]=trianglesCenters(this.level_seed_tris[1]);
      this.level_tris[1]=current.map(t=>t.map(p=>p.slice()));
      for(let lvl=2;lvl<=this.levels;lvl++){
        const sp3=calculateSymmetryPointAdjusted(this.center,this.radius,this.sides,lvl);
        this.level_symmetry[lvl]=[sp3[0],sp3[1]];
        this.level_seed_tris[lvl]=current.map(t=>t.map(p=>p.slice()));
        this.level_seed_centers[lvl]=trianglesCenters(this.level_seed_tris[lvl]);
        if(deferAtLevel===lvl){ this.level_tris[lvl]=null; break; }
        const copies=[this.level_seed_tris[lvl]];
        for(let i=1;i<this.sides;i++){const ang=(TAU/this.sides)*i; copies.push(rotateTrianglesAround(this.level_seed_tris[lvl],this.level_symmetry[lvl],ang))}
        current=copies.flat();
        this.level_tris[lvl]=current.map(t=>t.map(p=>p.slice()));
      }
    }
    activeTriangles(){const L=Math.max(0,this.levels|0);const tris=this.level_tris[L];return(tris&&tris.length)?tris:[]}
    activeSeedTris(){const L=Math.max(0,this.levels|0);return(this.level_seed_tris[L]??[])}
    activeCenters(){const L=Math.max(0,this.levels|0);return(this.level_seed_centers[L]??[])}
    activePivot(){const L=Math.max(0,this.levels|0);return(L<=1?this.center:(this.level_symmetry[L]??this.center))}
  }

  class App{
    constructor(){
      this.canvas=document.getElementById('canvas'); this.wrap=document.getElementById('canvasWrap'); this.ctx=this.canvas.getContext('2d');
      this.deferThreshold=400000;
      this.sidesInput=document.getElementById('sidesInput'); this.nMinus=document.getElementById('nMinus'); this.nPlus=document.getElementById('nPlus'); this.updateBtn=document.getElementById('updatePlot'); this.levelButtons=document.getElementById('levelButtons'); this.cancelBtn=document.getElementById('cancelGen');
      this.alphaInput=document.getElementById('alphaInput'); this.applyAlphaBtn=document.getElementById('applyAlpha'); this.autoAlphaBtn=document.getElementById('autoAlpha'); this.overlayAlpha=document.getElementById('overlayAlpha');
      this.toggleEdgesBtn=document.getElementById('toggleEdges'); this.colorModeBtn=document.getElementById('colorMode'); this.toggleBgBtn=document.getElementById('toggleBg');
      this.speedInput=document.getElementById('speedInput');
      this.speedPlus=document.getElementById('speedPlus'); this.speedMinus=document.getElementById('speedMinus'); this.toggleRotationBtn=document.getElementById('toggleRotation'); this.toggleEmergentBtn=document.getElementById('toggleEmergent'); this.pauseEmergentBtn=document.getElementById('pauseEmergent');
      this.stepBackBtn=document.getElementById('stepBack'); this.stepForwardBtn=document.getElementById('stepForward');
      this.snapMode=0;
      this.snapEnabled=false;
      this.toggleSnapBtn=document.getElementById('toggleSnap');
      this.stepBackBtn.addEventListener('click',()=>this._emergentStep(-1)); this.stepForwardBtn.addEventListener('click',()=>this._emergentStep(+1));
      this.zoomInBtn=document.getElementById('zoomIn'); this.zoomOutBtn=document.getElementById('zoomOut'); this.resetViewBtn=document.getElementById('resetView'); this.viewPortalBtn=document.getElementById('viewPortal');
      this.panLeftBtn=document.getElementById('panLeft'); this.panRightBtn=document.getElementById('panRight'); this.panUpBtn=document.getElementById('panUp'); this.panDownBtn=document.getElementById('panDown');
      this.entityPrevBtn=document.getElementById('entityPrev'); this.entityNextBtn=document.getElementById('entityNext');
      this.entityAutoBtn=document.getElementById('entityAuto'); this.entityLockBtn=document.getElementById('entityLock'); this.entityLabel=document.getElementById('entityLabel');
      this.exitFocusBtn=document.getElementById('exitFocus');
      this.toggleAudioBtn=document.getElementById('toggleAudio');
      this.toggleLiveFftBtn=document.getElementById('toggleLiveFft');
      this.cycleLiveEntityBtn=document.getElementById('cycleLiveEntity');
      this.audioStatusEl=document.getElementById('audioStatus');
      this.exportSpecBtn=document.getElementById('exportSpec'); this.importSpecBtn=document.getElementById('importSpec'); this.replaySpecBtn=document.getElementById('replaySpec');
      this.toggleSpecPanelBtn=document.getElementById('toggleSpecPanel');
      this.specInfoEl=document.getElementById('specInfo'); this.specFileInput=document.getElementById('specFileInput');
      this.sliceBinInput=document.getElementById('sliceBinInput'); this.toggleCubeSliceBtn=document.getElementById('toggleCubeSlice');
      this.downloadPngBtn=document.getElementById('downloadPng'); this.statusEl=document.getElementById('status'); this.codeLabel=document.getElementById('codeLabel'); this.graphStats=document.getElementById('graphStats');
      this.modeIndicator=document.getElementById('modeIndicator');
      this.tabButtons=Array.from(document.querySelectorAll('[data-tab]'));
      this.tabPanels=Array.from(document.querySelectorAll('[data-tab-panel]'));
      this.mainPanel=document.getElementById('mainPanel');
      this.specPanel=document.getElementById('specPanel');
      this.specCanvas=document.getElementById('specCanvas');
      this.specCtx=this.specCanvas?this.specCanvas.getContext('2d'):null;
      this.specReadout=document.getElementById('specReadout');
      this.waveCanvas=document.getElementById('waveCanvas');
      this.waveCtx=this.waveCanvas?this.waveCanvas.getContext('2d'):null;
      this.waveBuf=new Float32Array(2048);
      this.waveWrite=0;
      this.specViewOmegaLevelBtn=document.getElementById('specViewOmegaLevel');
      this.specViewOmegaTimeBtn=document.getElementById('specViewOmegaTime');
      this.specViewLevelTimeBtn=document.getElementById('specViewLevelTime');
      this.specZoomOmegaInBtn=document.getElementById('specZoomOmegaIn');
      this.specZoomOmegaOutBtn=document.getElementById('specZoomOmegaOut');
      this.specZoomLevelInBtn=document.getElementById('specZoomLevelIn');
      this.specZoomLevelOutBtn=document.getElementById('specZoomLevelOut');
      this.specZoomResetBtn=document.getElementById('specZoomReset');

      this.center=[0,0]; this.radius=1; this.sides=12; this.levels=2;
      this.edgesOnly=true; this.whiteBg=true; this.colorMode='distinct';
      this.alpha=0.02; this.rotationSpeed=0.50; this.globalAngle=0;
      this.lockedAngle=0;
      this.emergentAngle=0; this.rotationActive=false; this.emergentActive=false; this.emergentPaused=false;
      this.entityIndex=0; this.entityAuto=false; this.entityAutoTimer=null; this.entityAutoMs=2500; this.entityLockRotation=false;
      this.activeEntityK=0;
      this.entityFocusActive=false;
      this.focusModeActive=false;
      this.entityRevealActive=false;
      this.entityRevealRequest=null;
      this.entityRevealDurationMs=3800;
      this.primaryView="omega-level";
      this.cubeSliceBin=6;
      this.selectedOmega=this.cubeSliceBin;
      this.selectedLevel=this.levels;
      this._omegaLevelPanel=null;
      this._specPanelInfo=null;
      this.specPanelVisible=true;
      this.specZoomOmega=1;
      this.specZoomLevel=1;
      this.specPanOmega=0;
      this.specPanLevel=0;
      this._specLastReadout=null;
      // Live spectrogram (during Emergent)
      this.liveSpecEnabled=false;
      this.liveSpecEntityK=this.entityIndex ?? 0;
      this.liveSpecBins=128;
      this.liveSpecRows=120;
      this.liveSpecEveryMs=80;
      this.liveSpecSmoothing=0.3;
      this.liveSpecDbFloor=DB_FLOOR;
      this.liveSpecDbCeil=DB_CEIL;
      this._liveSpecLastTs=0;
      this._liveSpecAccumMs=0;
      this._liveSpecHead=0;
      this._liveSpecBuf=Array.from({length:this.liveSpecRows},()=>new Float32Array(this.liveSpecBins/2));
      this._liveSpecPrevMag=null;
      this._livePeaks=new Map();
      // Peak-hold state
      this._ridgeHold=new Map(); // bin -> strength [0..1]
      this._ridgeDecay=0.92;     // per-frame decay
      this._ridgeBoost=0.35;     // add when detected
      this._ridgeTopK=3;         // peaks per frame
      this._specFrames=[];
      this._specMeta=null;
      this._specRecordStart=0;
      this._specRecording=false;
      this._specReplayActive=false;
      this._specReplayIndex=0;
      this._specReplayStart=0;
      this._specReplayLevel=null;
      this._specReplaySmooth=0.35;
      this.showCubeSlice=true;
      this.fps=0; this._lastFrameTs=performance.now();
      this.scale=1; this.tx=0; this.ty=0; this.dragging=false; this.dragStart=[0,0]; this._popupShown=false;
      this.gen=new HLSFGenerator(this.center,this.radius,this.sides,this.levels);
      this._spectrogramCache={key:null,data:null};
      this._spectrogramCacheMap=new Map();
      this._fingerprintCache=new Map();
      this._omegaLevelCache=new Map();
      this._analysisBins=128;
      this._entitySignal=null;
      this._entityFFT=null;
      this._hudWarning=null;
      this.canvasFocused=false;
      // --- Audio (continuous noise filterbank) ---
      this.audioEnabled=true;         // start enabled for default audio playback
      this.audio=new AudioEngine();
      this._audioEveryMs=60;
      this._audioLastTs=0;
      this._lastAudioMag=null;

      this.sidesInput.value=String(this.sides);
      if (this.speedInput) this.speedInput.value = this.rotationSpeed.toFixed(3);
      if (this.sliceBinInput) this.sliceBinInput.value = String(this.cubeSliceBin);
      if(this.specCanvas){
        this.specCanvas.width=1024;
        this.specCanvas.height=512;
      }

      this._buildLevelButtons(); this._initTabs(); this._bindEvents(); this._resizeCanvas();
      this._exposeFingerprintApi();
      this._applyBg(); this.toggleEdgesBtn.textContent="Show Colors"; this._autoAlphaIfColors(); this.downloadPngBtn.textContent="Save PNG";
      this._updateButtonsEnabled(); this._updateSnapLabel(); this._updateEntityLabel(); this._updateSpecInfo(); this._setSpectrogramView(this.primaryView); this._updatePlot(true);
      this._syncAudioUi();
      this._bootAudio();
      this._loop();
    }

    _drawDeferred(seed,pivot,extraAngleRad=0){
      const [px,py]=pivot,[xmin,ymin,xmax,ymax]=this._worldViewRect(),corners=[[xmin,ymin],[xmin,ymax],[xmax,ymin],[xmax,ymax]];
      let Rmin=Infinity,Rmax=0; for(const c of corners){const d=Math.hypot(c[0]-px,c[1]-py); if(d<Rmin)Rmin=d; if(d>Rmax)Rmax=d}
      const pad=(Rmax-Rmin)*.25+.01; Rmin=Math.max(0,Rmin-pad); Rmax=Rmax+pad;
      const lw=this._lineWidthPx(), stroke=this.edgesOnly?(this.whiteBg?'rgba(0,0,0,1)':'rgba(255,255,255,1)'):null;
      let colorBySeed=null; if(!this.edgesOnly){const pal=buildHsvPalette(seed.length), a=this.alpha*Math.pow(.82,Math.max(0,this.levels-1)); colorBySeed=pal.map(([r,g,b,_])=>rgbaStr(r,g,b,a))}
      const triRadiusRange=(tri)=>{let r0=Infinity,r1=0; for(const p of tri){const d=Math.hypot(p[0]-px,p[1]-py); if(d<r0)r0=d; if(d>r1)r1=d} return[r0,r1]};
      const sides=this.sides;
      for(let si=0;si<seed.length;si++){
        const tri=seed[si],[r0,r1]=triRadiusRange(tri); if(r1<Rmin||r0>Rmax) continue;
        const fill=this.edgesOnly?null:colorBySeed[si%colorBySeed.length];
        for(let i=0;i<sides;i++){const ang=extraAngleRad+(TAU/sides)*i; const triRot=[rotatePointAround(tri[0],pivot,ang),rotatePointAround(tri[1],pivot,ang),rotatePointAround(tri[2],pivot,ang)]; this._drawTriangle(triRot,fill,stroke,lw)}
      }
    }

    _screenToWorld([sx,sy]){const x=(sx-this.tx)/(200*this.scale), y=-(sy-this.ty)/(200*this.scale); return[x,y]}
    _worldViewRect(){const w=this.canvas.clientWidth,h=this.canvas.clientHeight,p0=this._screenToWorld([0,0]),p1=this._screenToWorld([w,h]);return[Math.min(p0[0],p1[0]),Math.min(p0[1],p1[1]),Math.max(p0[0],p1[0]),Math.max(p0[1],p1[1])]}
    getVisibleTriangles(){
      const view=this._worldViewRect();
      return this.gen.activeTriangles().filter(tri =>
        triangleIntersectsRect(tri,view)
      );
    }
    _estimateTriangles(n,L){const t0=(n%2===0)?Math.floor(n/2):Math.floor(n/2)+1; if(L<=0) return t0; return t0*Math.pow(n,L)}
    _isPortalZoomed(){const [xmin,ymin,xmax,ymax]=this._worldViewRect(); return Math.hypot(xmax-xmin,ymax-ymin)<1.25 }

    _render(){ this._drawFrame(0); this._renderSpectrogramPanel(0); this._updateStatus(); this._drawnOnce=true }

    _buildLevelButtons(){ this.levelButtons.innerHTML=''; for(let L=0;L<=10;L++){const b=document.createElement('button'); b.className='lvl-btn'; b.textContent=String(L); if(L===this.levels)b.classList.add('active'); b.addEventListener('click',()=>this.setLevel(L)); this.levelButtons.appendChild(b)}}
    _markActiveLevel(){[...this.levelButtons.children].forEach((el,i)=>el.classList.toggle('active',i===this.levels))}
    _initTabs(){
      if(!this.tabButtons.length) return;
      this.tabButtons.forEach(btn=>{
        btn.addEventListener('click',()=>this._setActiveTab(btn.dataset.tab));
      });
      this._setActiveTab('geometry');
    }
    _setActiveTab(tabName){
      this.tabButtons.forEach(btn=>{
        const active=btn.dataset.tab===tabName;
        btn.setAttribute('aria-selected',String(active));
      });
      this.tabPanels.forEach(panel=>{
        panel.classList.toggle('active',panel.dataset.tabPanel===tabName);
      });
    }
    _setFocusMode(active){
      this.focusModeActive=active;
      document.body.classList.toggle('focus-mode',active);
    }
    _setAudioMode(active){
      document.body.classList.toggle('audio-mode',active);
    }
    _updateModeIndicator(){
      if(!this.modeIndicator) return;
      let mode='Explore';
      if(this.emergentActive) mode='Emergent';
      else if(this.rotationActive) mode='Motion';
      else if(this.entityFocusActive) mode='Entity';
      else if(this.focusModeActive) mode='Portal';
      if(this.audioEnabled) mode=`${mode} + Audio`;
      this.modeIndicator.textContent=`Mode: ${mode}`;
    }
    _syncAudioUi(){
      if(this.toggleAudioBtn){
        this.toggleAudioBtn.setAttribute('aria-pressed',String(this.audioEnabled));
        this.toggleAudioBtn.textContent=this.audioEnabled?"Audio: On":"Audio: Off";
      }
      if(this.toggleLiveFftBtn){
        this.toggleLiveFftBtn.setAttribute('aria-pressed',String(this.liveSpecEnabled));
        this.toggleLiveFftBtn.textContent=this.liveSpecEnabled?"Live FFT: On":"Live FFT: Off";
      }
      if(this.audioStatusEl){
        this.audioStatusEl.textContent=this.audioEnabled?"Audio enabled":"Audio muted";
      }
      this._setAudioMode(this.audioEnabled||this.liveSpecEnabled);
      this._updateModeIndicator();
    }
    _refreshAudioParams(){
      if(!this.audioEnabled) return;
      const mag=this._computeSpectrumForAudio({bins:64});
      if(mag){
        this._lastAudioMag=mag;
        this.audio.updateFromMagnitude(mag);
      } else if(this._lastAudioMag){
        this.audio.updateFromMagnitude(this._lastAudioMag);
      }
    }
    async _bootAudio(){
      if(!this.audioEnabled) return;
      await this.audio.init();
      await this.audio.resume();
      this.audio.setEnabled(true);
      this._refreshAudioParams();
    }
    async _toggleAudio(){
      this.audioEnabled=!this.audioEnabled;
      if(this.audioEnabled){
        await this._bootAudio();
      } else {
        this.audio.setEnabled(false);
      }
      const label=this.audioEnabled?"Audio enabled":"Audio muted";
      this._statusMsg(label);
      this._syncAudioUi();
    }
    _toggleLiveFft(){
      this.liveSpecEnabled=!this.liveSpecEnabled;
      this._statusMsg(this.liveSpecEnabled?"Live FFT: ON (Emergent)":"Live FFT: OFF");
      if(this.liveSpecEnabled){
        if(this.emergentActive) this._startSpectrogramRecording();
      } else {
        this._specRecording=false;
        this._specReplayActive=false;
        this._updateSpecInfo();
      }
      this._render();
      this._syncAudioUi();
    }
    _cycleLiveEntity(){
      this.liveSpecEntityK=(this.liveSpecEntityK+1)%this.sides;
      this._statusMsg(`Live FFT entity k = ${this.liveSpecEntityK}`);
      this._render();
    }

    _bindEvents(){
      const armAudio=async()=>{
        if(!this.audioEnabled) return;
        await this._bootAudio();
      };
      window.addEventListener('pointerdown',armAudio,{once:true,passive:true});
      window.addEventListener('keydown',armAudio,{once:true,passive:true});
      window.addEventListener('resize',()=>{this._resizeCanvas();this._render()},{passive:true});
      this.nMinus.addEventListener('click',()=>this._bumpSides(-1));
      this.nPlus.addEventListener('click',()=>this._bumpSides(+1));
      this.updateBtn.addEventListener('click',()=>this._applySidesFromInput());
      this.cancelBtn.addEventListener('click',()=>this._statusMsg("Generation cancelled."));
      this.applyAlphaBtn.addEventListener('click',()=>this._applyAlpha());
      this.autoAlphaBtn.addEventListener('click',()=>this._autoAlpha());
      this.toggleEdgesBtn.addEventListener('click',()=>this._toggleEdges());
      this.colorModeBtn.addEventListener('click',()=>this._toggleColorMode());
      this.toggleBgBtn.addEventListener('click',()=>this._toggleBg());
      if(this.toggleAudioBtn){
        this.toggleAudioBtn.addEventListener('click',()=>this._toggleAudio());
      }
      if(this.toggleLiveFftBtn){
        this.toggleLiveFftBtn.addEventListener('click',()=>this._toggleLiveFft());
      }
      if(this.cycleLiveEntityBtn){
        this.cycleLiveEntityBtn.addEventListener('click',()=>this._cycleLiveEntity());
      }

      // Rotation speed controls + sync
      this.speedPlus.addEventListener('click',()=>{this.rotationSpeed=Math.min(10,this.rotationSpeed+0.1);this._syncSpeedField();this._updateStatus()});
      this.speedMinus.addEventListener('click',()=>{this.rotationSpeed=Math.max(0.001,this.rotationSpeed-0.1);this._syncSpeedField();this._updateStatus()});
      if (this.speedInput){
        this.speedInput.addEventListener('change',()=>this._applySpeedFromInput());
        this.speedInput.addEventListener('blur',()=>this._applySpeedFromInput());
      }

      this.toggleRotationBtn.addEventListener('click',()=>this._toggleRotation());
      this.toggleEmergentBtn.addEventListener('click',()=>this._toggleEmergent());
      this.pauseEmergentBtn.addEventListener('click',()=>this._togglePauseEmergent());
      this.toggleSnapBtn.addEventListener('click',()=>{
        this.snapEnabled=!this.snapEnabled;
        this._updateSnapLabel();
        this._render();
      });
      this.zoomInBtn.addEventListener('click',()=>this._zoomAtCanvasPoint(1.1));
      this.zoomOutBtn.addEventListener('click',()=>this._zoomAtCanvasPoint(0.9));
      this.resetViewBtn.addEventListener('click',()=>this._resetView());
      this.viewPortalBtn.addEventListener('click',()=>this._viewPortal());
      this.panLeftBtn.addEventListener('click',()=>{this.tx-=50;this._render()});
      this.panRightBtn.addEventListener('click',()=>{this.tx+=50;this._render()});
      this.panUpBtn.addEventListener('click',()=>{this.ty-=50;this._render()});
      this.panDownBtn.addEventListener('click',()=>{this.ty+=50;this._render()});
      this.entityPrevBtn.addEventListener('click',()=>this._advanceEntity(-1));
      this.entityNextBtn.addEventListener('click',()=>this._advanceEntity(1));
      this.entityAutoBtn.addEventListener('click',()=>this._toggleEntityAuto());
      this.entityLockBtn.addEventListener('click',()=>this._toggleEntityLock());
      if(this.exitFocusBtn){
        this.exitFocusBtn.addEventListener('click',()=>this._resetView());
      }
      this.exportSpecBtn.addEventListener('click',()=>this.exportSpectrogramSession());
      this.importSpecBtn.addEventListener('click',()=>this._triggerSpecImport());
      this.replaySpecBtn.addEventListener('click',()=>this.replaySpectrogramSession());
      if(this.toggleSpecPanelBtn){
        this.toggleSpecPanelBtn.addEventListener('click',()=>this._toggleSpecPanel());
      }
      if(this.specViewOmegaLevelBtn){
        this.specViewOmegaLevelBtn.addEventListener('click',()=>this._setSpectrogramView('omega-level'));
        this.specViewOmegaTimeBtn.addEventListener('click',()=>this._setSpectrogramView('omega-time'));
        this.specViewLevelTimeBtn.addEventListener('click',()=>this._setSpectrogramView('level-time'));
      }
      if(this.specZoomOmegaInBtn){
        this.specZoomOmegaInBtn.addEventListener('click',()=>this._zoomSpectrogram({omega:1.15}));
        this.specZoomOmegaOutBtn.addEventListener('click',()=>this._zoomSpectrogram({omega:1/1.15}));
        this.specZoomLevelInBtn.addEventListener('click',()=>this._zoomSpectrogram({level:1.15}));
        this.specZoomLevelOutBtn.addEventListener('click',()=>this._zoomSpectrogram({level:1/1.15}));
        this.specZoomResetBtn.addEventListener('click',()=>this._resetSpectrogramZoom());
      }
      if(this.sliceBinInput){
        this.sliceBinInput.addEventListener('change',()=>this._applySliceBinFromInput());
        this.sliceBinInput.addEventListener('blur',()=>this._applySliceBinFromInput());
      }
      if(this.toggleCubeSliceBtn){
        this.toggleCubeSliceBtn.addEventListener('click',()=>this._toggleCubeSlice());
      }
      this.specFileInput.addEventListener('change',e=>this._handleSpecImportFile(e));
      this.downloadPngBtn.addEventListener('click',(e)=>{e.preventDefault();this._downloadPng()});
      this.canvas.addEventListener('mousedown',e=>{
        this.canvas.focus({preventScroll:true});
        this.dragging=true;
        this.dragMoved=false;
        this.dragStart=[e.clientX,e.clientY];
      });
      window.addEventListener('mousemove',e=>{
        if(!this.dragging)return;
        const dx=e.clientX-this.dragStart[0],dy=e.clientY-this.dragStart[1];
        if(Math.hypot(dx,dy)>3) this.dragMoved=true;
        this.tx+=dx; this.ty+=dy; this.dragStart=[e.clientX,e.clientY]; this._render();
      });
      window.addEventListener('mouseup',()=>{this.dragging=false});
      this.canvas.addEventListener('focus',()=>{
        this.canvasFocused=true;
      });
      this.canvas.addEventListener('blur',()=>{
        this.canvasFocused=false;
      });
      window.addEventListener('blur',()=>{
        this.canvasFocused=false;
      });
      this.canvas.addEventListener('wheel',e=>{e.preventDefault();const f=e.deltaY<0?1.1:0.9; this._zoomAtClientPoint(f,e.clientX,e.clientY); this._render(); this._refreshAudioParams()},{passive:false});
      if(this.specCanvas){
        this.specCanvas.addEventListener('mousemove',e=>this._updateSpectrogramReadout(e));
        this.specCanvas.addEventListener('mouseleave',()=>this._clearSpectrogramReadout());
        this.specCanvas.addEventListener('click',e=>this._handleOmegaLevelClick(e.clientX,e.clientY));
      }
      window.addEventListener('keydown',e=>{
        const ae=document.activeElement,typing=ae&&(ae.tagName==='INPUT'||ae.tagName==='TEXTAREA'||ae.isContentEditable===true);
        if(!typing){
          if(e.key==='['){this.focusEntity(--this.entityIndex); e.preventDefault(); return;}
          if(e.key===']'){this.focusEntity(++this.entityIndex); e.preventDefault(); return;}
          if(e.key.toLowerCase()==='f'){
            this._toggleLiveFft();
            return;
          }
          if(e.key.toLowerCase()==='m'){
            this._toggleAudio();
            return;
          }
          if(e.key.toLowerCase()==='g'){
            this._cycleLiveEntity();
            return;
          }
          if(e.key.toLowerCase()==='e'){
            this.exportSpectrogramSession();
            return;
          }
          if(e.key.toLowerCase()==='i'){
            this._triggerSpecImport();
            return;
          }
          if(e.key.toLowerCase()==='p'){
            this.replaySpectrogramSession();
            return;
          }
        }
        if(e.key==='ArrowLeft')this.tx-=50; else if(e.key==='ArrowRight')this.tx+=50; else if(e.key==='ArrowUp')this.ty-=50; else if(e.key==='ArrowDown')this.ty+=50; else if(e.key.toLowerCase()==='r')this._resetView();
        if(!typing&&this.emergentActive&&this.emergentPaused){ if(e.key===','){this._emergentStep(-1);e.preventDefault();return} if(e.key==='.') {this._emergentStep(+1);e.preventDefault();return}}
        this._render();
      });
    }

    _resizeCanvas(){
      const dpr=Math.max(1,window.devicePixelRatio||1), w=this.wrap.clientWidth||window.innerWidth, footer=document.querySelector('footer'), fh=footer?footer.getBoundingClientRect().height:0, h=(window.innerHeight-this.wrap.getBoundingClientRect().top-fh)|0;
      this.canvas.width=Math.max(1,(w*dpr)|0); this.canvas.height=Math.max(1,(h*dpr)|0);
      this.canvas.style.width=w+'px'; this.canvas.style.height=h+'px';
      this.ctx.setTransform(1,0,0,1,0,0); this.ctx.scale(dpr,dpr);
      if(this.waveCanvas && this.waveCtx){
        const waveDpr=Math.max(1,window.devicePixelRatio||1);
        const waveW=this.waveCanvas.clientWidth||600;
        const waveH=this.waveCanvas.clientHeight||140;
        this.waveCanvas.width=(waveW*waveDpr)|0;
        this.waveCanvas.height=(waveH*waveDpr)|0;
        this.waveCtx.setTransform(1,0,0,1,0,0);
        this.waveCtx.scale(waveDpr,waveDpr);
      }
    }

    _bumpSides(d){const cur=parseInt(this.sidesInput.value||this.sides,10), n=Math.max(4,cur+d); this.sidesInput.value=String(n); this._applySides(n)}
    _applySidesFromInput(){const n=Math.max(4,parseInt(this.sidesInput.value||this.sides,10)); this._applySides(n)}
    _applySides(n){this.sides=n; this.gen.setSides(n); this._popupShown=false; this._updatePlot(true); this._autoAlphaIfColors(); this._updateButtonsEnabled(); this._updateEntityLabel()}

    setLevel(L){
      this.levels=L; this.gen.setLevels(L); this._popupShown=false;
      this.selectedLevel=L;
      if(this.levels===0){this.edgesOnly=true; this.whiteBg=true; this.alpha=0.34; this.toggleEdgesBtn.textContent="Show Colors"} else {this._autoAlphaIfColors()}
      this._updatePlot(true); if(L>=3)this._viewPortal();
      this._updateButtonsEnabled(); this._markActiveLevel();
      this._updateSnapLabel();
      this._updateEntityLabel();
    }

    _applyAlpha(){const a=parseFloat(this.alphaInput.value); if(!isFinite(a)||a<0||a>1)return; this.alpha=a; this._updatePlot(true)}
    _autoAlpha(){const K=totalReplications(this.sides,this.levels); let opt=this.edgesOnly?this.alpha:(K>0?(3.636/K):this.alpha); this.alpha=clamp(opt,0.01,1); this.alphaInput.value=this.alpha.toFixed(4); this._updatePlot(true)}
    _autoAlphaIfColors(){if(!this.edgesOnly)this._autoAlpha()}
    _toggleEdges(){this.edgesOnly=!this.edgesOnly; if(this.edgesOnly){this.alpha=.5; this.toggleEdgesBtn.textContent="Show Colors"; this.whiteBg=true}else{this.toggleEdgesBtn.textContent="Show Outlines"; this._autoAlpha(); this.whiteBg=false} this._applyBg(); this._updatePlot(true); this._updateButtonsEnabled()}
    _toggleColorMode(){if(this.edgesOnly){this.edgesOnly=false; this.toggleEdgesBtn.textContent="Show Outlines"; this.whiteBg=false; this._applyBg()} this.colorMode=(this.colorMode==='by_level')?'distinct':'by_level'; this._autoAlpha(); this._updatePlot(true)}
    _toggleRotation(){
      if(this.entityLockRotation){this._statusMsg("Rotation locked during entity view."); return}
      if(this.rotationActive){this.rotationActive=false; this.toggleRotationBtn.textContent="Start Rotation"} else {this.rotationActive=true; this.emergentActive=false; this.emergentPaused=false; this.toggleEmergentBtn.textContent="Emergent Rotation"; this.pauseEmergentBtn.disabled=true; this.pauseEmergentBtn.textContent="Pause Emergent"; this.toggleRotationBtn.textContent="Stop Rotation"}
      this._updateModeIndicator();
    }
    _toggleEmergent(){
      if(this.entityLockRotation){this._statusMsg("Rotation locked during entity view."); return}
      if(this.emergentActive){
        this.emergentActive=false; this.emergentPaused=false; this.snapMode=0; this.toggleEmergentBtn.textContent="Emergent Rotation"; this.pauseEmergentBtn.disabled=true; this.pauseEmergentBtn.textContent="Pause Emergent";
        this._specRecording=false;
        this._specReplayActive=false;
        this._updateSpecInfo();
      }
      else{
        this.emergentActive=true; this.rotationActive=false; this.snapMode=2; this.toggleRotationBtn.textContent="Start Rotation"; this.toggleEmergentBtn.textContent="Stop Emergent Rotation"; this.pauseEmergentBtn.disabled=false; this._lastFrameTs=performance.now();
        if(this.liveSpecEnabled) this._startSpectrogramRecording();
      }
      this._updateButtonsEnabled(); this._updateHeaderLabels(); this._updateStatus(); this._render();
      this._updateSnapLabel();
      this._updateModeIndicator();
    }
    _togglePauseEmergent(){if(!this.emergentActive)return; this.emergentPaused=!this.emergentPaused; this.pauseEmergentBtn.textContent=this.emergentPaused?"Resume Emergent":"Pause Emergent"; this.stepBackBtn.disabled=!this.emergentPaused; this.stepForwardBtn.disabled=!this.emergentPaused}
    _applyBg(){this.wrap.style.background=this.whiteBg?'#fff':'#000'; this.toggleBgBtn.setAttribute('aria-pressed',String(this.whiteBg)); this.toggleBgBtn.textContent=this.whiteBg?"BG: White":"BG: Black"}
    _toggleBg(){this.whiteBg=!this.whiteBg; this._applyBg(); this._render()}
    _zoomAtCanvasPoint(f){const cx=this.canvas.clientWidth/2, cy=this.canvas.clientHeight/2; this._zoomAtClientPoint(f,cx,cy); this._render(); this._refreshAudioParams()}
    _zoomAtClientPoint(f,clientX,clientY){const rect=this.canvas.getBoundingClientRect(), x=clientX-rect.left, y=clientY-rect.top, prev=this.scale; this.scale*=f; this.tx=x-(x-this.tx)*(this.scale/prev); this.ty=y-(y-this.ty)*(this.scale/prev)}
    _resetView(){this.entityFocusActive=false; this._setFocusMode(false); this._stopEntityRevealTour(); this._zoomToDesignExtent(); this._render(); this._refreshAudioParams(); this._updateModeIndicator()}
    _viewPortal(){
      if(this.levels<1){this._statusMsg("View Portal is available only for levels ≥ 1."); return}
      this._stopEntityRevealTour();
      const pivot=this.gen.activePivot(), full=this.gen.activeTriangles(), tris=(full&&full.length)?full:this.gen.activeSeedTris(); if(!tris||!tris.length)return;
      let rmin=Infinity,rmax=0; for(const t of tris){for(const p of t){const d=Math.hypot(p[0]-pivot[0],p[1]-pivot[1]); if(d<rmin)rmin=d; if(d>rmax)rmax=d}}
      if(!isFinite(rmin)||rmin<=1e-9) rmin=Math.max(rmax*0.05,0.005);
      const R=Math.max(rmin*.95,0.005), [px,py]=pivot; this._zoomToRect([px-R,py-R,px+R,py+R]); this._setFocusMode(true); this._render(); this._refreshAudioParams(); this._updateModeIndicator();
    }
    _downloadPng(){
      try{
        this._render();
        const fn=`pdco_hlsf_fft__n${this.sides}_L${this.levels}.png`, a=document.createElement('a'); a.style.display='none';
        const trigger=(url,isBlob)=>{a.href=url;a.download=fn;a.target='_blank';a.rel='noopener';document.body.appendChild(a);a.click();document.body.removeChild(a); if(isBlob)setTimeout(()=>URL.revokeObjectURL(url),200); this._statusMsg(`PNG ${a.download?'downloaded':'opened in new tab'}: ${fn}`)};
        if(this.canvas.toBlob){this.canvas.toBlob((blob)=>{if(!blob){trigger(this.canvas.toDataURL('image/png'),false);return}trigger(URL.createObjectURL(blob),true)},'image/png')}
        else{trigger(this.canvas.toDataURL('image/png'),false)}
      }catch(err){console.error('PNG download failed:',err); this._statusMsg('PNG download failed — check console for details.')}
    }

    exportSpectrogramSession(){
      if(!this._specFrames.length){
        this._statusMsg("No spectrogram frames recorded yet.");
        return;
      }

      const bins=this.liveSpecBins/2;
      const payload={
        version:"hlsf-spec-v1",
        createdAt:new Date().toISOString(),
        entityK:this.liveSpecEntityK,
        levels:this.levels,
        levelsMax:this._specMeta?.levelsMax??this.levels,
        sides:this.sides,
        bins,
        selectedOmega:this.selectedOmega,
        selectedLevel:this.selectedLevel,
        frames:this._specFrames.map(f=>({t:f.t,fft:Array.from(f.bins),level:f.level}))
      };

      const blob=new Blob([JSON.stringify(payload)],{type:"application/json"});
      const a=document.createElement("a");
      a.href=URL.createObjectURL(blob);
      a.download=`hlsf_entity${payload.entityK}_L${payload.levels}.json`;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),200);
      this._statusMsg(`Exported spectrogram session (${this._specFrames.length} frames).`);
    }

    importSpectrogramSession(json){
      const data=JSON.parse(json);
      if(!data||!Array.isArray(data.frames)){
        this._statusMsg("Invalid spectrogram session JSON.");
        return;
      }

      const binsHalf=Number(data.bins)||0;
      if(binsHalf>0) this._resetLiveSpecBuffer(binsHalf);

      this._specFrames=data.frames.map(f=>({
        t:f.t,
        bins:Float32Array.from(f.fft),
        level:typeof f.level==="number"?f.level:undefined
      }));

      this._specMeta={
        entityK:typeof data.entityK==="number"?data.entityK:this.liveSpecEntityK,
        levels:typeof data.levels==="number"?data.levels:this.levels,
        levelsMax:typeof data.levelsMax==="number"?data.levelsMax:(typeof data.levels==="number"?data.levels:this.levels),
        sides:typeof data.sides==="number"?data.sides:this.sides,
        bins:binsHalf>0?binsHalf:(this.liveSpecBins/2),
        selectedOmega:typeof data.selectedOmega==="number"?data.selectedOmega:this.selectedOmega,
        selectedLevel:typeof data.selectedLevel==="number"?data.selectedLevel:this.selectedLevel
      };

      if(typeof this._specMeta.entityK==="number"){
        this.liveSpecEntityK=this._specMeta.entityK;
        this.activeEntityK=this._specMeta.entityK;
        this.entityIndex=this._specMeta.entityK;
        this._updateEntityLabel();
      }
      if(typeof this._specMeta.selectedOmega==="number"){
        this.selectedOmega=this._specMeta.selectedOmega;
        this.cubeSliceBin=clamp(Math.round(this.selectedOmega),1,this._resolveSliceBinLimit()-1);
        this._syncSliceBinField();
      }
      if(typeof this._specMeta.selectedLevel==="number"){
        this.selectedLevel=this._specMeta.selectedLevel;
        this.setLevel(Math.round(this.selectedLevel));
      }
      this._specRecording=false;
      this._specReplayActive=false;
      this._updateSpecInfo();
      this._statusMsg(`Loaded spectrogram session (${this._specFrames.length} frames).`);
      this._render();
    }

    replaySpectrogramSession(){
      if(!this._specFrames.length){
        this._statusMsg("No spectrogram session loaded to replay.");
        return;
      }
      const binsHalf=this._specMeta?.bins||this._specFrames[0]?.bins?.length||this.liveSpecBins/2;
      this._resetLiveSpecBuffer(binsHalf);
      if(this._specMeta?.entityK!==undefined){
        this.liveSpecEntityK=this._specMeta.entityK;
        this.activeEntityK=this._specMeta.entityK;
        this.entityIndex=this._specMeta.entityK;
        this._updateEntityLabel();
      }
      const firstLevel=this._specFrames[0]?.level ?? this._specMeta?.levels ?? this.levels;
      this._specReplayLevel=(typeof firstLevel==="number")?firstLevel:null;
      this.liveSpecEnabled=true;
      this._specReplayActive=true;
      this._specReplayIndex=0;
      this._specReplayStart=performance.now();
      this._livePeaks.clear();
      this._ridgeHold.clear();
      this._statusMsg(`Replaying spectrogram session (${this._specFrames.length} frames).`);
      this._render();
    }

    _triggerSpecImport(){
      if(this.specFileInput) this.specFileInput.click();
    }

    _handleSpecImportFile(e){
      const file=e.target?.files?.[0];
      if(!file) return;
      const reader=new FileReader();
      reader.onload=() => {
        try{
          this.importSpectrogramSession(String(reader.result||""));
        }catch(err){
          console.error("Import failed:",err);
          this._statusMsg("Import failed — invalid JSON.");
        }
      };
      reader.readAsText(file);
      e.target.value="";
    }

    _resetLiveSpecBuffer(binsHalf){
      const nextBins=Math.max(2,(binsHalf|0));
      this.liveSpecBins=nextBins*2;
      this._liveSpecBuf=Array.from({length:this.liveSpecRows},()=>new Float32Array(nextBins));
      this._liveSpecHead=0;
      this._liveSpecPrevMag=null;
      this._liveSpecAccumMs=0;
      this._livePeaks.clear();
      this._ridgeHold.clear();
    }

    _startSpectrogramRecording(){
      this._specFrames=[];
      this._specRecordStart=performance.now();
      this._specRecording=true;
      this._specReplayActive=false;
      this._liveSpecPrevMag=null;
      this._specMeta={
        entityK:this.liveSpecEntityK,
        levels:this.levels,
        levelsMax:this.levels,
        sides:this.sides,
        bins:this.liveSpecBins/2,
        selectedOmega:this.selectedOmega,
        selectedLevel:this.selectedLevel
      };
      this._updateSpecInfo();
    }

    _updateSpecInfo(){
      if(!this.specInfoEl) return;
      if(!this._specFrames.length){
        this.specInfoEl.textContent=this._specRecording?"Recording... (0 frames)":"No session loaded";
        return;
      }
      const bins=this._specMeta?.bins??(this.liveSpecBins/2);
      this.specInfoEl.textContent=`Frames: ${this._specFrames.length} | bins=${bins}`;
    }

    _visibleTris(){
      const base=this.gen.activeTriangles();
      if(!base||!base.length) return null;

      const [xmin,ymin,xmax,ymax]=this._worldViewRect();
      const out=[];
      for(const tri of base){
        const cx=(tri[0][0]+tri[1][0]+tri[2][0])/3;
        const cy=(tri[0][1]+tri[1][1]+tri[2][1])/3;
        if(cx>=xmin && cx<=xmax && cy>=ymin && cy<=ymax) out.push(tri);
      }
      return out.length ? out : null;
    }

    _pushWaveSample(x){
      if(!this.waveBuf) return;
      this.waveBuf[this.waveWrite]=x;
      this.waveWrite=(this.waveWrite+1)%this.waveBuf.length;
    }

    _updateWaveformSamples(){
      if(!this.waveBuf) return;
      const k=((this.entityIndex%this.sides)+this.sides)%this.sides;
      const signal=this.computeEntityTimeSignal(k,{sampleCount:256});
      if(!signal) return;
      for(let i=0;i<signal.length;i++) this._pushWaveSample(signal[i]);
    }

    _drawWaveformPanel(){
      if(!this.waveCanvas || !this.waveCtx) return;

      const ctx=this.waveCtx;
      const w=this.waveCanvas.clientWidth;
      const h=this.waveCanvas.clientHeight;

      ctx.clearRect(0,0,w,h);
      ctx.fillStyle=this.whiteBg?'#fff':'#000';
      ctx.fillRect(0,0,w,h);

      ctx.globalAlpha=0.25;
      ctx.strokeStyle=this.whiteBg?'#000':'#fff';
      ctx.beginPath();
      ctx.moveTo(0,h/2);
      ctx.lineTo(w,h/2);
      ctx.stroke();
      ctx.globalAlpha=1;

      ctx.strokeStyle=this.whiteBg?'#000':'#fff';
      ctx.lineWidth=1;

      const N=this.waveBuf.length;
      const start=this.waveWrite;
      ctx.beginPath();
      for(let i=0;i<N;i++){
        const idx=(start+i)%N;
        const v=this.waveBuf[idx];
        const x=(i/(N-1))*w;
        const y=(h/2)-v*(h*0.42);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();

      ctx.font='11px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillStyle=this.whiteBg?'#000':'#fff';
      ctx.fillText('Waveform (audio time-series)',8,14);
    }

    _computeSpectrumForAudio({bins=64}={}){
      const k=((this.entityIndex%this.sides)+this.sides)%this.sides;
      const resolvedBins=this._ensureFftBins(bins*2,"Audio FFT");

      const vTris=this._visibleTris();
      if(vTris){
        const sig=this._computeEntitySignalFromTris(vTris,k,resolvedBins);
        if(sig){
          const mag=this._fftMagnitude(sig);
          if(mag&&mag.length) return mag;
        }
      }

      const sigB=this._computeEntitySignal(k,resolvedBins);
      if(sigB){
        const magB=this._fftMagnitude(sigB);
        if(magB&&magB.length) return magB;
      }

      const sigC=this._computeEntitySignal(0,resolvedBins);
      if(sigC){
        const magC=this._fftMagnitude(sigC);
        if(magC&&magC.length) return magC;
      }

      return this._lastAudioMag ?? null;
    }

    _updateAudioTick(){
      const now=performance.now();
      if(now-this._audioLastTs<this._audioEveryMs) return;
      this._audioLastTs=now;

      if(this.audioEnabled){
        const mag=this._computeSpectrumForAudio({bins:64});
        if(mag){
          this._lastAudioMag=mag;
          this.audio.updateFromMagnitude(mag);
        } else if(this._lastAudioMag){
          this.audio.updateFromMagnitude(this._lastAudioMag);
        }
      }
      this._updateWaveformSamples();
    }

    analysisTick(dtSec){
      this._ensureDemoMode();
      this._updateEntitySignal();
      this._updateFFT();
      this._updateOmegaLevelCache();
    }

    _ensureDemoMode(){
      const anyAnalysisActive=this.liveSpecEnabled||this._specReplayActive||this.primaryView==="omega-level";
      if(anyAnalysisActive) return;
      this.liveSpecEnabled=true;
      this._setSpectrogramView("omega-level");
      if(this.emergentActive) this._startSpectrogramRecording();
      this._statusMsg("Demo mode: Live FFT enabled, view set to ω–L.");
    }

    _resolveActiveEntity(){
      const n=this.sides;
      const base=(this.activeEntityK??this.entityIndex??0);
      const normalized=((base%n)+n)%n;
      this.activeEntityK=normalized;
      if(this.entityIndex!==normalized) this.entityIndex=normalized;
      return normalized;
    }

    _updateEntitySignal(){
      const bins=this._ensureFftBins(this._analysisBins,"Entity Signal");
      this._analysisBins=bins;
      const k=this._resolveActiveEntity();
      this._entitySignal=this._computeEntitySignal(k,bins);
    }

    _updateFFT(){
      if(!this._entitySignal){this._entityFFT=null; return;}
      const bins=this._ensureFftBins(this._entitySignal.length,"FFT");
      if(bins!==this._entitySignal.length){
        this._analysisBins=bins;
        const k=this._resolveActiveEntity();
        this._entitySignal=this._computeEntitySignal(k,bins);
        if(!this._entitySignal){this._entityFFT=null; return;}
      }
      this._entityFFT=this._fftMagnitude(this._entitySignal);
    }

    _omegaLevelCacheKey({k,Lmax,bins}){
      return `${this.sides}:${Lmax}:${k}:${bins}:1`;
    }
    _computeOmegaLevel(Lmax){
      const k=this._resolveActiveEntity();
      const bins=this._ensureFftBins(this._analysisBins,"ω–L");
      this._analysisBins=bins;
      const {spec}=this._getNormalizedSpectrogram(k,{bins,Lmin:1,Lmax,allowCompute:true});
      if(!spec) return null;
      const cacheKey=this._omegaLevelCacheKey({k,Lmax,bins});
      this._omegaLevelCache.set(cacheKey,true);
      return spec;
    }
    _updateOmegaLevelCache(){
      const Lmax=Math.max(1,this._specMeta?.levelsMax??this.levels);
      const k=this._resolveActiveEntity();
      const bins=this._ensureFftBins(this._analysisBins,"ω–L");
      const cacheKey=this._omegaLevelCacheKey({k,Lmax,bins});
      if(this._omegaLevelCache.has(cacheKey)) return;
      this._computeOmegaLevel(Lmax);
    }

    _toggleSpecPanel(){
      this.specPanelVisible=!this.specPanelVisible;
      if(this.mainPanel){
        this.mainPanel.classList.toggle('spec-hidden',!this.specPanelVisible);
      }
      if(this.toggleSpecPanelBtn){
        this.toggleSpecPanelBtn.textContent=this.specPanelVisible?'Hide Panel':'Show Panel';
      }
      this._resizeCanvas();
      this._render();
    }

    _setSpectrogramView(view){
      this.primaryView=view;
      const setBtn=(btn,active)=>{
        if(!btn) return;
        btn.classList.toggle('btn-primary',active);
        btn.classList.toggle('btn-neutral',!active);
        btn.setAttribute('aria-pressed',String(active));
      };
      setBtn(this.specViewOmegaLevelBtn,view==='omega-level');
      setBtn(this.specViewOmegaTimeBtn,view==='omega-time');
      setBtn(this.specViewLevelTimeBtn,view==='level-time');
      this._clearSpectrogramReadout();
      this._renderSpectrogramPanel(0);
    }

    _zoomSpectrogram({omega=null,level=null}={}){
      if(omega){
        this.specZoomOmega=clamp(this.specZoomOmega*omega,1,8);
      }
      if(level){
        this.specZoomLevel=clamp(this.specZoomLevel*level,1,8);
      }
      this._renderSpectrogramPanel(0);
    }

    _resetSpectrogramZoom(){
      this.specZoomOmega=1;
      this.specZoomLevel=1;
      this.specPanOmega=0;
      this.specPanLevel=0;
      this._renderSpectrogramPanel(0);
    }

    _clearSpectrogramReadout(){
      if(!this.specReadout) return;
      this.specReadout.textContent='ω — | L — | val —';
      this._specLastReadout=null;
    }

    _updateSpectrogramReadout(evt){
      if(!this.specReadout||!this._specPanelInfo) return;
      const rect=this.specCanvas.getBoundingClientRect();
      const x=evt.clientX-rect.left;
      const y=evt.clientY-rect.top;
      const info=this._specPanelInfo;
      const next=info.readoutAt(x,y);
      if(!next) return;
      if(next!==this._specLastReadout){
        this.specReadout.textContent=next;
        this._specLastReadout=next;
      }
    }

    _renderSpectrogramPanel(dtSec){
      if(!this.specPanelVisible||!this.specCtx||!this.specCanvas) return;
      const view=this.primaryView;
      const specEntity=this._specReplayActive
        ? (this._specMeta?.entityK ?? this.liveSpecEntityK ?? this.activeEntityK)
        : this.activeEntityK;
      const Lmax=this._specMeta?.levelsMax??this.levels;
      if(view==='omega-level'){
        this._drawOmegaLevelSpectrogram(specEntity,{Lmax});
      } else if(view==='omega-time'){
        this._drawOmegaTimeSpectrogram();
      } else if(view==='level-time'){
        this._drawLevelTimeSpectrogram({Lmax});
      }
    }

    _pushHudWarning(msg,ttlMs=2500){
      this._hudWarning={msg,expires:performance.now()+ttlMs};
    }
    _isPowerOfTwo(n){
      return n>0 && (n & (n-1))===0;
    }
    _nearestPowerOfTwo(n){
      if(n<=1) return 1;
      const power=Math.round(Math.log2(n));
      return Math.pow(2,power);
    }
    _ensureFftBins(bins,context="FFT"){
      const raw=Math.max(2,Math.round(bins||0));
      if(this._isPowerOfTwo(raw)) return raw;
      const adjusted=Math.max(2,this._nearestPowerOfTwo(raw));
      if(adjusted!==raw){
        this._pushHudWarning(`${context}: bins rounded to ${adjusted} (was ${raw})`);
      }
      return adjusted;
    }

    _updateButtonsEnabled(){this.viewPortalBtn.disabled=this.levels<1; this.pauseEmergentBtn.disabled=!this.emergentActive; const step=this.emergentActive&&this.emergentPaused; this.stepBackBtn.disabled=!step; this.stepForwardBtn.disabled=!step}
    _emergentStep(dir){
      if(!(this.emergentActive&&this.emergentPaused)){this._statusMsg("Step: pause Emergent first."); return}
      const mode=this._resolveSnapMode();
      const step=
        mode===1 ? (TAU/this.sides)
        : mode===2 ? (Math.PI/this.sides)
        : (Math.PI/180);
      this.emergentAngle+=dir*step;
      this._render();
    }

    _syncSpeedField(){
      if (this.speedInput) this.speedInput.value = this.rotationSpeed.toFixed(3);
    }
    _applySpeedFromInput(){
      if (!this.speedInput) return;
      const v = parseFloat(this.speedInput.value);
      if (!isFinite(v)) { this._syncSpeedField(); return; }
      this.rotationSpeed = clamp(v, 0.001, 10);
      this._syncSpeedField();
      this._updateStatus();
    }
    _syncSliceBinField(){
      if (this.sliceBinInput) this.sliceBinInput.value = String(this.cubeSliceBin);
    }
    _resolveSliceBinLimit(){
      const binsFromMeta=this._specMeta?.bins;
      const binsFromFrames=this._specFrames[0]?.bins?.length;
      const bins=Math.max(
        binsFromMeta ?? 0,
        binsFromFrames ?? 0,
        this.liveSpecBins/2
      );
      return Math.max(2, bins|0);
    }
    _applySliceBinFromInput(){
      if (!this.sliceBinInput) return;
      const v=parseInt(this.sliceBinInput.value,10);
      if (!Number.isFinite(v)) { this._syncSliceBinField(); return; }
      const limit=this._resolveSliceBinLimit();
      this.cubeSliceBin=clamp(v,1,limit-1);
      this.selectedOmega=this.cubeSliceBin;
      this._syncSliceBinField();
      this._render();
    }
    _toggleCubeSlice(){
      this.showCubeSlice=!this.showCubeSlice;
      if(this.toggleCubeSliceBtn){
        this.toggleCubeSliceBtn.setAttribute('aria-pressed',String(this.showCubeSlice));
        this.toggleCubeSliceBtn.textContent=this.showCubeSlice?'L×t Slice':'L×t Slice (Off)';
      }
      this._render();
    }

    _warnIfHeavy(){
      if(this._popupShown||this.levels<2) return true;
      let triCount=this.sides; for(let i=2;i<=this.levels;i++) triCount+=Math.pow(this.sides,i);
      const est=triCount*0.000033; if(est>3){this._popupShown=true; return window.confirm(`This configuration will generate ~${triCount} triangles and may take ~${est.toFixed(2)}s.\nContinue?`)} return true;
    }

    _updatePlot(recompute=false){
      const estimated=this._estimateTriangles(this.sides,this.levels), wantDefer=estimated>this.deferThreshold&&(this._isPortalZoomed()||this.levels>=5);
      if(!wantDefer && !this._warnIfHeavy()) return;
      if(recompute) this.gen.computeLevels(wantDefer?{deferAtLevel:this.levels}:undefined);
      if(recompute){
        this._spectrogramCache={key:null,data:null};
        if(this._spectrogramCacheMap) this._spectrogramCacheMap.clear();
        if(this._fingerprintCache) this._fingerprintCache.clear();
        if(this._omegaLevelCache) this._omegaLevelCache.clear();
      }

      const K=totalReplications(this.sides,this.levels), a=clamp(this.alpha,0,1), cumulative=1-Math.pow(1-a,Math.min(K,5000));
      this.overlayAlpha.textContent=cumulative.toFixed(3);
      if(cumulative>=0.9999){ if(!this.edgesOnly){this.edgesOnly=true; this.toggleEdgesBtn.textContent="Show Colors"; this.whiteBg=true; this._applyBg()} this.toggleEdgesBtn.disabled=true } else { this.toggleEdgesBtn.disabled=false }

      if(!wantDefer) this._zoomToDesignExtent();
      this._updateHeaderLabels(); this._updateStatus(); this._render(); this._refreshAudioParams();
    }

    _entityRadiusBounds(){
      const n=this.sides, L=this.levels, rf=(n%2===1)?Math.cos(Math.PI/n):1;
      if(L<=1){return {rMin:0, rMax:this.radius};}
      let rMax=0;
      for(let cur=2;cur<=L;cur++) rMax+=this.radius*multiplier(cur,n)*rf;
      const rMin=this.radius*multiplier(L,n)*rf;
      return {rMin:Math.max(0,rMin), rMax:Math.max(rMin,rMax)};
    }
    _triangleInEntity(tri,k){
      const n=this.sides;
      const pivot=this.gen.activePivot();
      const theta0=canonicalStartAngle(n);
      const dTheta=TAU/n;

      const kk=((k%n)+n)%n;
      const a0=theta0+kk*dTheta;
      const a1=a0+dTheta;

      const cx=(tri[0][0]+tri[1][0]+tri[2][0])/3;
      const cy=(tri[0][1]+tri[1][1]+tri[2][1])/3;

      let ang=Math.atan2(cy-pivot[1],cx-pivot[0]);
      if(ang<0) ang+=TAU;

      let aa0=a0%TAU;
      let aa1=a1%TAU;

      if(aa0<0) aa0+=TAU;
      if(aa1<0) aa1+=TAU;

      return aa0<aa1
        ? (ang>=aa0&&ang<aa1)
        : (ang>=aa0||ang<aa1);
    }
    _triangleCentroid(tri){
      return [
        (tri[0][0]+tri[1][0]+tri[2][0])/3,
        (tri[0][1]+tri[1][1]+tri[2][1])/3
      ];
    }
    _triangleArea(tri){
      const [ax,ay]=tri[0];
      const [bx,by]=tri[1];
      const [cx,cy]=tri[2];
      return Math.abs((bx-ax)*(cy-ay)-(by-ay)*(cx-ax))/2;
    }
    _triangleVisibility(tri,view){
      const [xmin,ymin,xmax,ymax]=view;
      const cx=(tri[0][0]+tri[1][0]+tri[2][0])/3;
      const cy=(tri[0][1]+tri[1][1]+tri[2][1])/3;
      return (cx>=xmin&&cx<=xmax&&cy>=ymin&&cy<=ymax) ? 1 : 0;
    }
    _levelWeight(level){
      return Math.pow(0.78, level);
    }
    _mapRadiusToOmega(r,{omegaMin=1,omegaMax=64,rMin=null,rMax=null}={}){
      const bounds=this._entityRadiusBounds();
      const minR=Number.isFinite(rMin)?rMin:bounds.rMin;
      const maxR=Number.isFinite(rMax)?rMax:bounds.rMax;
      if(!(maxR>minR)) return omegaMin;
      const t=clamp((r-minR)/(maxR-minR),0,1);
      const logMin=Math.log(Math.max(1e-6,omegaMin));
      const logMax=Math.log(Math.max(omegaMin+1e-6,omegaMax));
      const logOmega=logMin+t*(logMax-logMin);
      return Math.exp(logOmega);
    }
    computeEntityTimeSignal(k,{sampleCount=2048,dt=null,omegaMax=64,levelWeight=null}={}){
      const tris=this.gen.activeTriangles();
      if(!tris||!tris.length) return null;

      const pivot=this.gen.activePivot();
      const resolvedDt=dt??(1/sampleCount);
      const bounds=this._entityRadiusBounds();
      const rMin=bounds.rMin;
      const rMax=bounds.rMax;
      const lw=levelWeight??(1/Math.max(1,this.levels));
      const phaseOffset=this.emergentActive ? this.emergentAngle : this.globalAngle;

      const inEntity=[];
      for(const tri of tris){
        if(this._triangleInEntity(tri,k)) inEntity.push(tri);
      }
      if(!inEntity.length) return new Float32Array(sampleCount);

      let maxArea=0;
      for(const tri of inEntity){
        maxArea=Math.max(maxArea,this._triangleArea(tri));
      }
      if(!(maxArea>0)) maxArea=1;

      const signal=new Float32Array(sampleCount);
      for(const tri of inEntity){
        const [cx,cy]=this._triangleCentroid(tri);
        const r=Math.hypot(cx-pivot[0],cy-pivot[1]);
        const omega=this._mapRadiusToOmega(r,{omegaMin:1,omegaMax,rMin,rMax});
        const amp=(this._triangleArea(tri)/maxArea)*lw;
        const phi=phaseOffset+Math.atan2(cy-pivot[1],cx-pivot[0]);

        for(let i=0;i<sampleCount;i++){
          signal[i]+=amp*Math.sin(omega*i*resolvedDt+phi);
        }
      }
      return signal;
    }
    _computeEntitySignal(k,bins=128){
      const tris=this.gen.activeTriangles();
      if(!tris||!tris.length) return null;

      const n=this.sides;
      const L=this.levels;

      let rMin=this.radius;
      let rMax=rMin;

      if(L>=2){
        let acc=0;
        for(let cur=2;cur<=L;cur++){
          const rf=(n%2===1)?Math.cos(Math.PI/n):1;
          acc+=this.radius*multiplier(cur,n)*rf;
        }
        rMax=acc;
      }

      const dr=(rMax-rMin)/bins;
      if(!(dr>0)) return null;
      const signal=new Float32Array(bins);

      const pivot=this.gen.activePivot();

      for(const tri of tris){
        if(!this._triangleInEntity(tri,k)) continue;

        const cx=(tri[0][0]+tri[1][0]+tri[2][0])/3;
        const cy=(tri[0][1]+tri[1][1]+tri[2][1])/3;
        const r=Math.hypot(cx-pivot[0],cy-pivot[1]);

        const idx=Math.floor((r-rMin)/dr);
        if(idx>=0&&idx<bins){
          signal[idx]+=1;
        }
      }

      return signal;
    }
    _computeEntitySignalFromTris(tris,k,bins=128){
      if(!tris||!tris.length) return null;

      const n=this.sides;
      const L=this.levels;
      const pivot=this.gen.activePivot();

      let rMin=this.radius;
      let rMax=rMin;

      if(L>=2){
        let acc=0;
        for(let cur=2;cur<=L;cur++){
          const rf=(n%2===1)?Math.cos(Math.PI/n):1;
          acc+=this.radius*multiplier(cur,n)*rf;
        }
        rMax=acc;
      }

      const dr=(rMax-rMin)/bins;
      if(!(dr>0)) return null;

      const signal=new Float32Array(bins);

      for(const tri of tris){
        if(!this._triangleInEntity(tri,k)) continue;

        const cx=(tri[0][0]+tri[1][0]+tri[2][0])/3;
        const cy=(tri[0][1]+tri[1][1]+tri[2][1])/3;

        const r=Math.hypot(cx-pivot[0],cy-pivot[1]);
        const idx=Math.floor((r-rMin)/dr);
        if(idx>=0&&idx<bins) signal[idx]+=1;
      }

      return signal;
    }
    _computeEntitySpectrogram(k,{Lmin=1,Lmax=this.levels,bins=128}={}){
      const originalLevels=this.levels;
      const spectra=[];
      const resolvedBins=this._ensureFftBins(bins,"ω–L");

      for(let L=Lmin;L<=Lmax;L++){
        this.levels=L;
        this.gen.setLevels(L);
        this.gen.computeLevels();

        const signal=this._computeEntitySignal(k,resolvedBins);
        if(!signal){
          spectra.push(null);
          continue;
        }

        const mag=this._fftMagnitude(signal);
        spectra.push(mag);
      }

      this.levels=originalLevels;
      this.gen.setLevels(originalLevels);
      this.gen.computeLevels();

      return spectra;
    }
    _normalizeSpectrogram(spectra){
      return spectra.map((row)=>{
        if(!row) return null;
        const normalized=new Float32Array(row.length);
        for(let i=0;i<row.length;i++){
          normalized[i]=dbToNorm(magToDb(row[i]));
        }
        return normalized;
      });
    }
    _spectrogramKey(k,{bins,Lmin,Lmax}){
      return `${this.sides}:${Lmax}:${k}:${bins}:${Lmin}`;
    }
    _getNormalizedSpectrogram(k,{bins=128,Lmin=1,Lmax=null,allowCompute=false}={}){
      const resolvedLmax=(Lmax??this._specMeta?.levelsMax??this.levels);
      const cacheKey=this._spectrogramKey(k,{bins,Lmin,Lmax:resolvedLmax});
      const cached=this._spectrogramCacheMap?.get(cacheKey);
      if(cached) return {spec:cached, resolvedLmax, cacheKey};
      if(!allowCompute) return {spec:null, resolvedLmax, cacheKey};
      const raw=this._computeEntitySpectrogram(k,{bins,Lmin,Lmax:resolvedLmax});
      const spec=this._normalizeSpectrogram(raw);
      this._spectrogramCache={key:cacheKey,data:spec};
      this._spectrogramCacheMap?.set(cacheKey,spec);
      return {spec, resolvedLmax, cacheKey};
    }
    _computeFingerprintFromSpectrogram(spec,{epsilon=0.15,topN=5,Lmin=1}={}){
      const rows=spec?.length??0;
      if(rows===0) return null;
      const firstRow=spec.find(row=>row);
      if(!firstRow) return null;
      const cols=firstRow.length;
      const bins=Math.max(1,cols-1);
      const persistence=new Float32Array(bins);
      let validRows=0;

      for(let y=0;y<rows;y++){
        const row=spec[y];
        if(!row) continue;
        validRows+=1;
        for(let x=1;x<cols;x++){
          if(row[x]>epsilon) persistence[x-1]+=1;
        }
      }

      if(validRows>0){
        for(let i=0;i<persistence.length;i++) persistence[i]/=validRows;
      }

      const persistenceList=Array.from(persistence,(v,i)=>({idx:i+1,val:v}));
      persistenceList.sort((a,b)=>b.val-a.val||a.idx-b.idx);
      const peakSpine=new Float32Array(topN);
      for(let i=0;i<topN;i++){
        const entry=persistenceList[i];
        peakSpine[i]=entry ? (entry.idx/(cols-1)) : 0;
      }

      const centroids=[];
      for(let y=0;y<rows;y++){
        const row=spec[y];
        if(!row) continue;
        let sum=0;
        let weighted=0;
        for(let x=1;x<cols;x++){
          const v=row[x];
          sum+=v;
          weighted+=v*x;
        }
        if(sum>0){
          centroids.push((weighted/sum)/(cols-1));
        }
      }

      let centroidSlope=0;
      let centroidVar=0;
      if(centroids.length>=2){
        const n=centroids.length;
        const meanX=(n-1)/2;
        let meanY=0;
        for(const v of centroids) meanY+=v;
        meanY/=n;
        let cov=0;
        let varX=0;
        let varY=0;
        for(let i=0;i<n;i++){
          const dx=i-meanX;
          const dy=centroids[i]-meanY;
          cov+=dx*dy;
          varX+=dx*dx;
          varY+=dy*dy;
        }
        centroidSlope=varX>0?cov/varX:0;
        centroidVar=varY/n;
      } else if(centroids.length===1){
        centroidVar=0;
      }

      let evenEnergy=0;
      let oddEnergy=0;
      for(let y=0;y<rows;y++){
        const row=spec[y];
        if(!row) continue;
        let rowEnergy=0;
        for(let x=1;x<cols;x++) rowEnergy+=row[x];
        const level=Lmin+y;
        if(level%2===0) evenEnergy+=rowEnergy;
        else oddEnergy+=rowEnergy;
      }
      const parity=(evenEnergy+oddEnergy)>0?(evenEnergy-oddEnergy)/(evenEnergy+oddEnergy):0;

      const omegaEnergy=new Float32Array(bins);
      let totalEnergy=0;
      for(let y=0;y<rows;y++){
        const row=spec[y];
        if(!row) continue;
        for(let x=1;x<cols;x++){
          omegaEnergy[x-1]+=row[x];
        }
      }
      for(let i=0;i<omegaEnergy.length;i++) totalEnergy+=omegaEnergy[i];
      let entropy=0;
      if(totalEnergy>0){
        const logBase=Math.log2(bins);
        for(let i=0;i<omegaEnergy.length;i++){
          const p=omegaEnergy[i]/totalEnergy;
          if(p>0) entropy-=p*Math.log2(p);
        }
        if(logBase>0) entropy/=logBase;
      }

      const fingerprint=new Float32Array(
        persistence.length + peakSpine.length + 4
      );
      let offset=0;
      fingerprint.set(persistence,offset); offset+=persistence.length;
      fingerprint.set(peakSpine,offset); offset+=peakSpine.length;
      fingerprint[offset++]=centroidSlope;
      fingerprint[offset++]=centroidVar;
      fingerprint[offset++]=parity;
      fingerprint[offset++]=entropy;
      return fingerprint;
    }
    computeEntityFingerprint(k,{bins=128,Lmin=1,Lmax=null,epsilon=0.15,topN=5}={}){
      const {spec,resolvedLmax,cacheKey}=this._getNormalizedSpectrogram(k,{bins,Lmin,Lmax,allowCompute:false});
      if(!spec){
        this._statusMsg("Fingerprint requires cached ω–L data. Render the ω–L view first.");
        return null;
      }
      const fpKey=`${cacheKey}:${epsilon}:${topN}`;
      const cached=this._fingerprintCache?.get(fpKey);
      if(cached) return cached;
      const fingerprint=this._computeFingerprintFromSpectrogram(spec,{epsilon,topN,Lmin});
      if(fingerprint) this._fingerprintCache?.set(fpKey,fingerprint);
      return fingerprint;
    }
    compareFingerprints(f1,f2){
      if(!f1||!f2) return 0;
      const n=Math.min(f1.length,f2.length);
      if(n===0) return 0;
      let dot=0;
      let a=0;
      let b=0;
      for(let i=0;i<n;i++){
        const x=f1[i];
        const y=f2[i];
        dot+=x*y;
        a+=x*x;
        b+=y*y;
      }
      if(a<=0||b<=0) return 0;
      return dot/Math.sqrt(a*b);
    }
    _drawOmegaLevelSpectrogram(k,{bins=128,Lmin=1,Lmax=null}={}){
      const resolvedBins=this._ensureFftBins(bins,"ω–L");
      const {spec,resolvedLmax,cacheKey}=this._getNormalizedSpectrogram(k,{bins:resolvedBins,Lmin,Lmax,allowCompute:false});
      if(spec&&this._spectrogramCache?.key!==cacheKey){
        this._spectrogramCache={key:cacheKey,data:spec};
      }

      const ctx=this.specCtx;
      if(!ctx) return;
      const w=this.specCanvas.width;
      const h=this.specCanvas.height;

      ctx.save();
      ctx.fillStyle='#05060a';
      ctx.fillRect(0,0,w,h);

      if(!spec||!spec.length){
        ctx.fillStyle='rgba(255,255,255,0.6)';
        ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
        ctx.fillText('ω–L cache warming…',12,18);
        ctx.restore();
        this._specPanelInfo=null;
        return;
      }

      const rows=spec.length;
      const cols=spec.find(row=>row)?.length??0;
      const omegaMax=Math.max(2,cols-1);
      const totalLevels=Math.max(1,resolvedLmax-Lmin+1);

      const logMin=Math.log(1);
      const logMax=Math.log(omegaMax);
      const logSpan=logMax-logMin||1;
      const omegaZoom=clamp(this.specZoomOmega,1,8);
      const omegaSpan=logSpan/omegaZoom;
      const omegaCenter=clamp(logMin+logSpan*(0.5+this.specPanOmega),logMin+omegaSpan/2,logMax-omegaSpan/2);
      const omegaMinLog=omegaCenter-omegaSpan/2;
      const omegaMaxLog=omegaCenter+omegaSpan/2;

      const levelZoom=clamp(this.specZoomLevel,1,8);
      const levelSpan=totalLevels/levelZoom;
      const levelCenter=clamp(Lmin+totalLevels*(0.5+this.specPanLevel),Lmin+levelSpan/2,resolvedLmax-levelSpan/2);
      const levelMin=levelCenter-levelSpan/2;
      const levelMax=levelCenter+levelSpan/2;

      const omegaBins=new Int16Array(w);
      for(let x=0;x<w;x++){
        const u=x/(w-1);
        const logOmega=omegaMinLog+u*(omegaMaxLog-omegaMinLog);
        omegaBins[x]=clamp(Math.round(Math.exp(logOmega)),1,omegaMax);
      }

      const img=ctx.createImageData(w,h);
      const data=img.data;
      for(let y=0;y<h;y++){
        const v=1-(y/(h-1));
        const level=levelMin+v*(levelMax-levelMin);
        const rowIndex=Math.round(level)-Lmin;
        if(rowIndex<0||rowIndex>=rows){
          continue;
        }
        const row=spec[rowIndex];
        if(!row) continue;
        for(let x=0;x<w;x++){
          const bin=omegaBins[x];
          const val=row[bin]??0;
          if(val<=0) continue;
          const intensity=Math.pow(val,0.82);
          const [r,g,b]=_specColorRgb(intensity);
          const idx=(y*w+x)*4;
          data[idx]=r;
          data[idx+1]=g;
          data[idx+2]=b;
          data[idx+3]=255;
        }
      }
      ctx.putImageData(img,0,0);

      ctx.strokeStyle='rgba(255,255,255,0.08)';
      ctx.lineWidth=1;
      for(let omega=1;omega<=omegaMax;omega*=2){
        const u=(Math.log(omega)-omegaMinLog)/(omegaMaxLog-omegaMinLog||1);
        const x=u*w;
        if(x<0||x>w) continue;
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,h);
        ctx.stroke();
      }

      const levelStep=Math.max(1,Math.round(totalLevels/12));
      ctx.strokeStyle='rgba(255,255,255,0.06)';
      for(let L=Lmin;L<=resolvedLmax;L+=levelStep){
        const u=(levelMax-L)/(levelMax-levelMin||1);
        const y=u*h;
        if(y<0||y>h) continue;
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(w,y);
        ctx.stroke();
      }

      const omegaValue=Number.isFinite(this.selectedOmega)?this.selectedOmega:this.cubeSliceBin;
      const levelValue=Number.isFinite(this.selectedLevel)?this.selectedLevel:this.levels;
      const omega=clamp(Math.round(omegaValue),1,omegaMax);
      const level=clamp(Math.round(levelValue),Lmin,resolvedLmax);
      const omegaX=((Math.log(omega)-omegaMinLog)/(omegaMaxLog-omegaMinLog||1))*w;
      const levelY=((levelMax-level)/(levelMax-levelMin||1))*h;
      ctx.strokeStyle='rgba(255,255,255,0.55)';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(omegaX,0);
      ctx.lineTo(omegaX,h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,levelY);
      ctx.lineTo(w,levelY);
      ctx.stroke();

      const emergence=this._detectEmergenceLevel(spec);
      const stability=this._computeStabilityScore(spec);
      const stabilityLabel=Number.isFinite(stability)?` | stability=${stability.toFixed(2)}`:'';
      const emergenceLabel=(emergence!==null)?` | emergence=L${emergence}`:'';
      ctx.fillStyle='rgba(255,255,255,0.85)';
      ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillText(`ω–L | k=${k+1} | L=${Lmin}-${resolvedLmax}${stabilityLabel}${emergenceLabel}`,12,18);
      ctx.restore();

      this._omegaLevelPanel={
        x0:0,y0:0,w,h,Lmin,resolvedLmax,
        omegaMinLog,omegaMaxLog,levelMin,levelMax,omegaMax
      };

      this._specPanelInfo={
        view:'omega-level',
        readoutAt:(x,y)=>{
          if(x<0||y<0||x>w||y>h) return null;
          const u=clamp(x/w,0,1);
          const logOmega=omegaMinLog+u*(omegaMaxLog-omegaMinLog);
          const omegaBin=clamp(Math.round(Math.exp(logOmega)),1,omegaMax);
          const v=1-clamp(y/h,0,1);
          const levelBin=clamp(Math.round(levelMin+v*(levelMax-levelMin)),Lmin,resolvedLmax);
          const rowIndex=levelBin-Lmin;
          const row=spec[rowIndex];
          const value=row?.[omegaBin]??0;
          return `ω ${omegaBin} | L ${levelBin} | val ${value.toFixed(3)}`;
        }
      };
    }
    _drawOmegaLevelCursor({x0,y0,w,h,cellSize,cols,rows,Lmin,resolvedLmax}){
      const omegaValue=Number.isFinite(this.selectedOmega)?this.selectedOmega:this.cubeSliceBin;
      const levelValue=Number.isFinite(this.selectedLevel)?this.selectedLevel:this.levels;
      const omega=clamp(Math.round(omegaValue),1,cols-1);
      const level=clamp(Math.round(levelValue),Lmin,resolvedLmax);
      const cursorX=x0+omega*cellSize;
      const cursorRow=level-Lmin;
      if(cursorRow<0||cursorRow>=rows) return;

      const cursorY=y0+cursorRow*cellSize;
      const ctx=this.ctx;
      ctx.strokeStyle=this.whiteBg?'#000':'#fff';
      ctx.globalAlpha=0.85;
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(cursorX,y0-6);
      ctx.lineTo(cursorX,y0+h+6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x0-6,cursorY+cellSize/2);
      ctx.lineTo(x0+w+6,cursorY+cellSize/2);
      ctx.stroke();
      ctx.globalAlpha=0.9;
      ctx.strokeRect(x0-6,cursorY-1,w+12,cellSize+2);
      ctx.globalAlpha=1;
    }
    _handleOmegaLevelClick(clientX,clientY){
      if(this.primaryView!=="omega-level") return;
      if(!this.specPanelVisible) return;
      if(!this._omegaLevelPanel) return;
      if(!this.specCanvas) return;
      const rect=this.specCanvas.getBoundingClientRect();
      const x=clientX-rect.left;
      const y=clientY-rect.top;
      const {x0,y0,w,h,Lmin,resolvedLmax,omegaMinLog,omegaMaxLog,levelMin,levelMax,omegaMax}=this._omegaLevelPanel;
      if(x<x0||x>x0+w||y<y0||y>y0+h) return;
      const u=clamp((x-x0)/w,0,1);
      const v=1-clamp((y-y0)/h,0,1);
      const omegaBin=clamp(Math.round(Math.exp(omegaMinLog+u*(omegaMaxLog-omegaMinLog))),1,omegaMax);
      const level=clamp(Math.round(levelMin+v*(levelMax-levelMin)),Lmin,resolvedLmax);
      this.onOmegaLevelClick({omegaBin,level});
    }
    onOmegaLevelClick({omegaBin,level}){
      this.selectedOmega=omegaBin;
      this.selectedLevel=level;
      this.cubeSliceBin=omegaBin;
      this._syncSliceBinField();
      this.setLevel(level);
      this.focusEntity(this.entityIndex,{animate:false});
      this._render();
    }
    _computeStabilityScore(spec){
      if(!spec||!spec.length) return null;
      let sum=0;
      let count=0;
      for(const row of spec){
        if(!row) continue;
        let max=0;
        for(let i=1;i<row.length;i++) max=Math.max(max,row[i]);
        sum+=max;
        count+=1;
      }
      if(!count) return null;
      return sum/count;
    }
    _drawLevelTimeSpectrogram({bin=this.cubeSliceBin,Lmin=1,Lmax=null}={}){
      if(!this.showCubeSlice){
        const ctx=this.specCtx;
        if(ctx){
          ctx.save();
          ctx.fillStyle='#05060a';
          ctx.fillRect(0,0,this.specCanvas.width,this.specCanvas.height);
          ctx.fillStyle='rgba(255,255,255,0.6)';
          ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText('L–t slice disabled. Enable L×t Slice.',12,18);
          ctx.restore();
        }
        this._specPanelInfo=null;
        return;
      }
      if(!this._specFrames.length){
        const ctx=this.specCtx;
        if(ctx){
          ctx.save();
          ctx.fillStyle='#05060a';
          ctx.fillRect(0,0,this.specCanvas.width,this.specCanvas.height);
          ctx.fillStyle='rgba(255,255,255,0.6)';
          ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillText('No L–t frames recorded yet.',12,18);
          ctx.restore();
        }
        this._specPanelInfo=null;
        return;
      }
      const frames=this._specFrames;
      const bins=frames[0]?.bins?.length;
      if(!bins) return;

      const resolvedBin=clamp(Math.round(bin),1,bins-1);
      this.cubeSliceBin=resolvedBin;
      this._syncSliceBinField();

      let framesLmax=0;
      for(const frame of frames){
        if(typeof frame.level!=="number") continue;
        framesLmax=Math.max(framesLmax,Math.round(frame.level));
      }
      const resolvedLmax=Math.max(Lmax??this._specMeta?.levelsMax??this.levels,framesLmax);
      if(resolvedLmax<Lmin) return;

      const rows=resolvedLmax-Lmin+1;
      const cols=Math.min(240,frames.length);
      if(cols<=1) return;

      const grid=Array.from({length:rows},()=>new Float32Array(cols));
      const duration=Math.max(1,frames[frames.length-1]?.t ?? frames.length-1);

      for(const frame of frames){
        if(typeof frame.level!=="number") continue;
        const row=Math.round(frame.level)-Lmin;
        if(row<0||row>=rows) continue;
        const t=Math.max(0,frame.t??0);
        const col=Math.round((t/duration)*(cols-1));
        const val=frame.bins?.[resolvedBin] ?? 0;
        if(val<=0) continue;
        const prev=grid[row][col];
        if(val>prev) grid[row][col]=val;
      }

      const ctx=this.specCtx;
      if(!ctx) return;
      const w=this.specCanvas.width;
      const h=this.specCanvas.height;

      ctx.save();
      ctx.fillStyle='#05060a';
      ctx.fillRect(0,0,w,h);

      const img=ctx.createImageData(w,h);
      const data=img.data;
      for(let y=0;y<h;y++){
        const v=1-(y/(h-1));
        const rowIndex=Math.round(v*(rows-1));
        const row=grid[rowIndex];
        if(!row) continue;
        for(let x=0;x<w;x++){
          const u=x/(w-1);
          const col=Math.round(u*(cols-1));
          const val=row[col];
          if(val<=0) continue;
          const [r,g,b]=_specColorRgb(Math.pow(val,0.85));
          const idx=(y*w+x)*4;
          data[idx]=r;
          data[idx+1]=g;
          data[idx+2]=b;
          data[idx+3]=255;
        }
      }
      ctx.putImageData(img,0,0);

      ctx.strokeStyle='rgba(255,255,255,0.08)';
      const tStep=Math.max(1,Math.round(cols/10));
      for(let c=0;c<=cols-1;c+=tStep){
        const x=(c/(cols-1))*w;
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,h);
        ctx.stroke();
      }

      const levelStep=Math.max(1,Math.round(rows/12));
      for(let L=0;L<rows;L+=levelStep){
        const y=(1-(L/(rows-1)))*h;
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(w,y);
        ctx.stroke();
      }

      ctx.fillStyle='rgba(255,255,255,0.85)';
      ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillText(`L–t | ω${resolvedBin} | L=${Lmin}-${resolvedLmax}`,12,18);
      ctx.restore();

      this._specPanelInfo={
        view:'level-time',
        readoutAt:(x,y)=>{
          if(x<0||y<0||x>w||y>h) return null;
          const u=clamp(x/w,0,1);
          const col=Math.round(u*(cols-1));
          const v=1-clamp(y/h,0,1);
          const rowIndex=Math.round(v*(rows-1));
          const level=Lmin+rowIndex;
          const value=(grid[rowIndex]?.[col]??0);
          return `t ${col} | L ${level} | val ${value.toFixed(3)}`;
        }
      };
    }
    _trackLivePeaks(mag){
      const topK=3;
      const peaks=[...mag.entries()]
        .slice(1)
        .sort((a,b)=>b[1]-a[1])
        .slice(0,topK);
      const peakBins=new Set(peaks.map(([bin])=>bin));
      for(const [bin] of peaks){
        this._livePeaks.set(bin,(this._livePeaks.get(bin)||0)+1);
      }
      for(const [bin,count] of this._livePeaks.entries()){
        if(peakBins.has(bin)) continue;
        const next=count-1;
        if(next<=0) this._livePeaks.delete(bin);
        else this._livePeaks.set(bin,next);
      }
    }
    _updateRidgeHold(mag){
      // detect local peaks
      const peaks=[];
      for(let i=2;i<mag.length-2;i++){
        if(mag[i]>mag[i-1]&&mag[i]>mag[i+1]){
          peaks.push([i,mag[i]]);
        }
      }
      peaks.sort((a,b)=>b[1]-a[1]);
      const top=peaks.slice(0,this._ridgeTopK);

      // decay existing
      for(const [bin,val] of this._ridgeHold.entries()){
        const next=val*this._ridgeDecay;
        if(next<0.02) this._ridgeHold.delete(bin);
        else this._ridgeHold.set(bin,next);
      }

      // reinforce detected peaks
      for(const [bin,val] of top){
        const cur=this._ridgeHold.get(bin)||0;
        const weight=1-(bin/mag.length);
        this._ridgeHold.set(bin,Math.min(1,cur+val*weight*this._ridgeBoost));
      }
    }
    _updateLiveSpectrogram(tris,dtSec){
      if(!this.liveSpecEnabled) return;
      if(!this.emergentActive) return;
      if(this.emergentPaused) return;

      const now=performance.now();
      const dtMs=(dtSec||0)*1000;
      this._liveSpecAccumMs+=dtMs;
      if(this._liveSpecAccumMs<this.liveSpecEveryMs) return;
      while(this._liveSpecAccumMs>=this.liveSpecEveryMs){
        this._liveSpecAccumMs-=this.liveSpecEveryMs;
      }
      this._liveSpecLastTs=now;

      if(this._specReplayActive){
        while(this._specReplayIndex<this._specFrames.length){
          const frame=this._specFrames[this._specReplayIndex];
          if((now-this._specReplayStart)<frame.t) break;
          this._liveSpecBuf[this._liveSpecHead].set(frame.bins);
          this._liveSpecHead=(this._liveSpecHead+1)%this.liveSpecRows;
          this._trackLivePeaks(frame.bins);
          this._updateRidgeHold(frame.bins);
          if(typeof frame.level==="number"){
            if(this._specReplayLevel===null){
              this._specReplayLevel=frame.level;
            } else {
              this._specReplayLevel+= (frame.level-this._specReplayLevel)*this._specReplaySmooth;
            }
          }
          this._specReplayIndex+=1;
        }
        if(this._specReplayIndex>=this._specFrames.length){
          this._specReplayActive=false;
          this._specReplayLevel=null;
          this._statusMsg("Spectrogram replay complete.");
        }
        return;
      }

      const adjustedBins=this._ensureFftBins(this.liveSpecBins,"Live FFT");
      if(adjustedBins!==this.liveSpecBins){
        this._resetLiveSpecBuffer(adjustedBins/2);
      }
      const bins=this.liveSpecBins;
      const k=((this.liveSpecEntityK%this.sides)+this.sides)%this.sides;

      const sig=this._computeEntitySignalFromTris(tris,k,bins);
      if(!sig) return;

      const mag=this._fftMagnitude(sig);
      const alpha=this.liveSpecSmoothing;
      const prev=this._liveSpecPrevMag;
      if(prev){
        for(let i=1;i<mag.length;i++){
          mag[i]=alpha*mag[i]+(1-alpha)*prev[i];
        }
      }
      this._liveSpecPrevMag=Float32Array.from(mag);

      this._trackLivePeaks(mag);

      const normalized=new Float32Array(mag.length);
      for(let i=1;i<mag.length;i++){
        normalized[i]=dbToNorm(magToDb(mag[i]));
      }

      this._updateRidgeHold(normalized);
      this._liveSpecBuf[this._liveSpecHead].set(normalized);
      this._liveSpecHead=(this._liveSpecHead+1)%this.liveSpecRows;

      if(this._specRecording){
        this._specFrames.push({
          t:this._specFrames.length*this.liveSpecEveryMs,
          bins:Float32Array.from(normalized),
          level:this.levels
        });
        if(this._specMeta){
          this._specMeta.levelsMax=Math.max(this._specMeta.levelsMax??this.levels,this.levels);
        }
        this._updateSpecInfo();
      }
    }
    _drawOmegaTimeSpectrogram(){
      const ctx=this.specCtx;
      if(!ctx) return;
      if(!this.liveSpecEnabled&&!this._specReplayActive){
        ctx.save();
        ctx.fillStyle='#05060a';
        ctx.fillRect(0,0,this.specCanvas.width,this.specCanvas.height);
        ctx.fillStyle='rgba(255,255,255,0.6)';
        ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
        ctx.fillText('Live FFT disabled. Press F to enable.',12,18);
        ctx.restore();
        this._specPanelInfo=null;
        return;
      }

      const cols=this.liveSpecRows;
      const bins=this.liveSpecBins/2;
      const w=this.specCanvas.width;
      const h=this.specCanvas.height;

      ctx.save();
      ctx.fillStyle='rgba(5,6,10,0.18)';
      ctx.fillRect(0,0,w,h);

      const logMin=Math.log(1);
      const logMax=Math.log(Math.max(2,bins-1));
      const logSpan=logMax-logMin||1;
      const omegaZoom=clamp(this.specZoomOmega,1,8);
      const omegaSpan=logSpan/omegaZoom;
      const omegaCenter=clamp(logMin+logSpan*(0.5+this.specPanOmega),logMin+omegaSpan/2,logMax-omegaSpan/2);
      const omegaMinLog=omegaCenter-omegaSpan/2;
      const omegaMaxLog=omegaCenter+omegaSpan/2;

      const omegaBins=new Int16Array(h);
      for(let y=0;y<h;y++){
        const v=1-(y/(h-1));
        const logOmega=omegaMinLog+v*(omegaMaxLog-omegaMinLog);
        omegaBins[y]=clamp(Math.round(Math.exp(logOmega)),1,bins-1);
      }

      const img=ctx.createImageData(w,h);
      const data=img.data;
      for(let x=0;x<w;x++){
        const u=x/(w-1);
        const col=Math.round(u*(cols-1));
        const idx=(this._liveSpecHead+col)%cols;
        const row=this._liveSpecBuf[idx];
        if(!row) continue;
        const fade=0.2+0.8*(col/Math.max(1,cols-1));
        for(let y=0;y<h;y++){
          const bin=omegaBins[y];
          const val=row[bin]??0;
          if(val<=0) continue;
          const intensity=Math.pow(val,0.9)*fade;
          const [r,g,b]=_specColorRgb(intensity);
          const offset=(y*w+x)*4;
          data[offset]=r;
          data[offset+1]=g;
          data[offset+2]=b;
          data[offset+3]=255;
        }
      }
      ctx.putImageData(img,0,0);

      ctx.strokeStyle='rgba(255,255,255,0.08)';
      for(let omega=1;omega<=bins-1;omega*=2){
        const u=(Math.log(omega)-omegaMinLog)/(omegaMaxLog-omegaMinLog||1);
        const y=(1-u)*h;
        if(y<0||y>h) continue;
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(w,y);
        ctx.stroke();
      }

      ctx.fillStyle='rgba(255,255,255,0.85)';
      ctx.font='12px ui-monospace, Menlo, Consolas, monospace';
      const label=`ω–t | k=${this.liveSpecEntityK+1} | hop=${this.liveSpecEveryMs}ms`;
      ctx.fillText(label,12,18);
      ctx.restore();

      this._specPanelInfo={
        view:'omega-time',
        readoutAt:(x,y)=>{
          if(x<0||y<0||x>w||y>h) return null;
          const u=clamp(x/w,0,1);
          const col=Math.round(u*(cols-1));
          const rowIdx=(this._liveSpecHead+col)%cols;
          const v=1-clamp(y/h,0,1);
          const logOmega=omegaMinLog+v*(omegaMaxLog-omegaMinLog);
          const omegaBin=clamp(Math.round(Math.exp(logOmega)),1,bins-1);
          const value=this._liveSpecBuf[rowIdx]?.[omegaBin]??0;
          const tMs=col*this.liveSpecEveryMs;
          return `ω ${omegaBin} | t ${tMs}ms | val ${value.toFixed(3)}`;
        }
      };
    }
    _detectEmergenceLevel(spec){
      for(let i=0;i<spec.length;i++){
        const row=spec[i];
        if(!row) continue;

        let energy=0;
        let peak=0;
        for(let j=0;j<row.length;j++){
          const v=row[j];
          energy+=v;
          if(v>peak) peak=v;
        }

        if(energy>0&&peak/energy>0.18) return i+1;
      }
      return null;
    }
    _fftMagnitude(signal){
      const N=signal.length;
      if(!this._isPowerOfTwo(N)){
        const adjusted=this._ensureFftBins(N,"FFT");
        const resized=new Float32Array(adjusted);
        resized.set(signal.subarray(0,Math.min(signal.length,adjusted)));
        return this._fftMagnitude(resized);
      }
      const re=new Float32Array(signal);
      const im=new Float32Array(N);

      for(let len=2;len<=N;len<<=1){
        const half=len>>1;
        const step=TAU/len;

        for(let i=0;i<N;i+=len){
          for(let j=0;j<half;j++){
            const k=i+j;
            const l=k+half;

            const ang=step*j;
            const wr=Math.cos(ang);
            const wi=-Math.sin(ang);

            const tr=wr*re[l]-wi*im[l];
            const ti=wr*im[l]+wi*re[l];

            re[l]=re[k]-tr;
            im[l]=im[k]-ti;
            re[k]+=tr;
            im[k]+=ti;
          }
        }
      }

      const mag=new Float32Array(N/2);
      for(let i=1;i<mag.length;i++){
        mag[i]=Math.hypot(re[i],im[i]);
      }
      return mag;
    }
    _drawEntityFFTOverlay(k){
      const bins=this._ensureFftBins(128,"FFT Overlay");
      const sig=this._computeEntitySignal(k,bins);
      if(!sig) return;

      const mag=this._fftMagnitude(sig);
      if(!mag||!mag.length) return;

      const ctx=this.ctx;
      const w=220,h=120;
      const x=16,y=16;

      ctx.save();
      ctx.globalAlpha=0.9;
      ctx.fillStyle=this.whiteBg?'#fff':'#000';
      ctx.fillRect(x,y,w,h);

      ctx.strokeStyle=this.whiteBg?'#000':'#fff';
      ctx.strokeRect(x,y,w,h);

      let max=0;
      for(let i=1;i<mag.length;i++) max=Math.max(max,mag[i]);
      if(!(max>0)) max=1;

      ctx.beginPath();
      for(let i=1;i<mag.length;i++){
        const px=x+(i/mag.length)*w;
        const py=y+h-(mag[i]/max)*h;
        if(i===1) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }
    _drawLiveSpectrogramHUD(){
      if(!this.liveSpecEnabled || !this.emergentActive) return;

      const ctx=this.ctx;
      const rows=this.liveSpecRows;
      const bins=this.liveSpecBins/2;

      const panelW=Math.min(520,this.canvas.clientWidth*0.45);
      const panelH=Math.min(300,this.canvas.clientHeight*0.45);

      const x0=16;
      const y0=this.canvas.clientHeight-panelH-16;

      // --- background ---
      ctx.save();
      ctx.globalAlpha=0.96;
      ctx.fillStyle=this.whiteBg?'#fff':'#000';
      ctx.fillRect(x0-6,y0-6,panelW+12,panelH+12);
      ctx.strokeStyle=this.whiteBg?'#000':'#fff';
      ctx.strokeRect(x0-6,y0-6,panelW+12,panelH+12);

      // --- log-frequency mapping ---
      const fMin=1;
      const fMax=bins-1;
      const logMin=Math.log(fMin);
      const logMax=Math.log(fMax);

      const binToY=(bin)=>{
        const u=(Math.log(bin)-logMin)/(logMax-logMin);
        return y0+panelH-u*panelH;
      };

      const colW=panelW/rows;

      // --- draw waterfall (time → left) ---
      for(let t=0;t<rows;t++){
        const bufIdx=(this._liveSpecHead-1-t+rows)%rows;
        const mag=this._liveSpecBuf[bufIdx];
        if(!mag) continue;

        const x=x0+panelW-t*colW;

        for(let b=1;b<bins;b++){
          const v=mag[b];
          if(v<=0) continue;

          // dB compression
          const db=20*Math.log10(v+1e-6);
          const norm=clamp((db+60)/60,0,1);

          if(norm<=0) continue;

          const y=binToY(b);
          const yNext=binToY(b+1);
          const h=Math.max(1,yNext-y);

          const intensity=Math.floor(norm*255);
          ctx.fillStyle=this.whiteBg
            ? `rgb(${255-intensity},${255-intensity},${255-intensity})`
            : `rgb(${intensity},${intensity},${intensity})`;

          ctx.fillRect(x,y,colW+1,h+1);
        }
      }

      // --- ridge overlays ---
      ctx.save();
      ctx.lineWidth=1;

      const binToRidgeY=(bin)=>{
        const u=(Math.log(bin)-logMin)/(logMax-logMin);
        return y0+panelH-u*panelH;
      };

      for(const [bin,strength] of this._ridgeHold.entries()){
        if(bin<=1||bin>=bins) continue;
        const y=binToRidgeY(bin);
        const alpha=clamp(strength,0,1);
        ctx.strokeStyle=this.whiteBg
          ? `rgba(0,0,0,${alpha})`
          : `rgba(180,220,255,${alpha})`;

        ctx.beginPath();
        ctx.moveTo(x0,y);
        ctx.lineTo(x0+panelW,y);
        ctx.stroke();
      }
      ctx.restore();

      // --- labels ---
      ctx.globalAlpha=1;
      ctx.fillStyle=this.whiteBg?'#000':'#fff';
      ctx.font='11px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillText(
        `Live Spectrogram (Waterfall) | k=${this.liveSpecEntityK} | log ω`,
        x0,
        y0-10
      );

      ctx.restore();
    }
    _updateEntityLabel(){
      const n=this.sides;
      const normalized=((this.activeEntityK??this.entityIndex)%n+n)%n;
      this.activeEntityK=normalized;
      this.entityIndex=normalized;
      this.liveSpecEntityK=normalized;
      if(this.entityLabel) this.entityLabel.textContent=`Entity ${normalized+1} / ${n}`;
    }
    _stopRotationsForEntity(){
      if(this.rotationActive||this.emergentActive){
        this.lockedAngle=this.emergentActive ? this.emergentAngle : this.globalAngle;
        this.rotationActive=false;
        this.emergentActive=false;
        this.emergentPaused=false;
        this.toggleRotationBtn.textContent="Start Rotation";
        this.toggleEmergentBtn.textContent="Emergent Rotation";
        this.pauseEmergentBtn.disabled=true;
        this.pauseEmergentBtn.textContent="Pause Emergent";
        this._updateButtonsEnabled();
        this._updateModeIndicator();
      }
    }
    focusEntity(k,{animate=true}={}){
      const n=this.sides;
      if(n<3) return;

      const theta0=canonicalStartAngle(n);
      const dTheta=TAU/n;

      const kk=((k%n)+n)%n;
      const {rMax}=this._entityRadiusBounds();
      const rFar=Math.max(0.01,rMax);
      const rNear=Math.max(rFar*0.02,0.005);
      const targetRect=this._portalRectForEntity(kk,rNear,rFar,{radial:0.08,tangential:0.2});

      this.entityIndex=kk;
      this.activeEntityK=kk;
      this.liveSpecEntityK=kk;
      this.entityFocusActive=true;
      this._setFocusMode(true);
      if(this.entityLockRotation) this._stopRotationsForEntity();
      this._updateEntityLabel();
      this._stopEntityRevealTour();
      this._updateModeIndicator();

      if(!animate){
        this._zoomToRect(targetRect);
        this._render();
        this._refreshAudioParams();
        this._startEntityRevealTour(kk,rNear,rFar);
        return;
      }

      this._animateZoomToRect(targetRect,420,()=>{
        this._startEntityRevealTour(kk,rNear,rFar);
        this._refreshAudioParams();
      });
    }
    _advanceEntity(dir){
      const n=this.sides;
      this.entityIndex=((this.entityIndex+dir)%n+n)%n;
      this.focusEntity(this.entityIndex);
    }
    _toggleEntityAuto(){
      if(this.primaryView==="omega-level"){
        this._statusMsg("Primary view locked to ω–L; auto-advance is disabled.");
        return;
      }
      this.entityAuto=!this.entityAuto;
      this.entityAutoBtn.setAttribute('aria-pressed',String(this.entityAuto));
      this.entityAutoBtn.textContent=this.entityAuto?"Auto-Advance: ON":"Auto-Advance";
      if(this.entityAuto){
        this.focusEntity(this.entityIndex);
        this.entityAutoTimer=window.setInterval(()=>this._advanceEntity(1),this.entityAutoMs);
      } else if(this.entityAutoTimer){
        window.clearInterval(this.entityAutoTimer);
        this.entityAutoTimer=null;
      }
    }
    _toggleEntityLock(){
      this.entityLockRotation=!this.entityLockRotation;
      this.entityLockBtn.setAttribute('aria-pressed',String(this.entityLockRotation));
      this.entityLockBtn.textContent=this.entityLockRotation?"Lock Rotation: ON":"Lock Rotation";
      if(this.entityLockRotation){
        this.lockedAngle=this.emergentActive ? this.emergentAngle : this.globalAngle;
        this._stopRotationsForEntity();
      }
    }

    _worldToScreen([x,y]){const sx=x*(200*this.scale)+this.tx, sy=-y*(200*this.scale)+this.ty; return[sx,sy]}
    _screenCenterWeight(cx,cy){
      const sx=cx*(200*this.scale)+this.tx;
      const sy=-cy*(200*this.scale)+this.ty;
      const halfW=this.canvas.clientWidth/2;
      const halfH=this.canvas.clientHeight/2;
      if(!(halfW>0&&halfH>0)) return 0;
      const dx=(sx-halfW)/halfW;
      const dy=(sy-halfH)/halfH;
      const d=Math.sqrt(dx*dx+dy*dy);
      return clamp(1-d,0,1);
    }
    _attentionGain(w){
      return Math.pow(w,0.35);
    }
    _drawTriangle(tri,fill,stroke,lw){const ctx=this.ctx,p0=this._worldToScreen(tri[0]),p1=this._worldToScreen(tri[1]),p2=this._worldToScreen(tri[2]); ctx.beginPath(); ctx.moveTo(p0[0],p0[1]); ctx.lineTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.closePath(); if(fill){ctx.fillStyle=fill;ctx.fill()} if(stroke){ctx.strokeStyle=stroke;ctx.lineWidth=lw;ctx.stroke()}}
    _paletteByLevel(L,seedCount,a0){const R=(L===0)?1:this.sides, colors=buildHsvPalette(R), out=[], a=a0*Math.pow(.82,Math.max(0,L-1)); for(let r=0;r<R;r++){const [rr,gg,bb]=colors[r]; for(let k=0;k<seedCount;k++) out.push(rgbaStr(rr,gg,bb,a))} return out}
    _paletteDistinct(seedCount,L,a0,R){const base=buildHsvPalette(seedCount), a=a0*Math.pow(.82,Math.max(0,L-1)), seed=base.map(([r,g,b,_])=>rgbaStr(r,g,b,a)), out=[]; for(let s=0;s<R;s++) out.push(...seed); return out}
    _currentColorArray(allTris){const L=Math.max(0,this.levels|0), seed=this.gen.activeSeedTris(), seedCount=seed.length, R=(L===0)?1:this.sides, T=seedCount*R; if(this.edgesOnly||T===0) return new Array(allTris.length).fill(null); const a=this.alpha; if(this.colorMode==='by_level'){const arr=this._paletteByLevel(L,seedCount,a); return allTris.map((_,i)=>arr[i%arr.length])} else {const arr=this._paletteDistinct(seedCount,L,a,R); return allTris.map((_,i)=>arr[i%arr.length])}}
    _lineWidthPx(){return Math.max(.5,2/(this.levels+1))}
    _resolveSnapMode(){
      if(!this.snapEnabled) return 0;
      if(this.emergentActive || (this.levels%2===1)) return 2;
      return (this.levels%2===0) ? 1 : 2;
    }
    _updateSnapLabel(){
      const mode=this._resolveSnapMode();
      let label='OFF';
      if(mode===1) label=`360/${this.sides}`;
      if(mode===2) label=`360/${2*this.sides}`;
      this.toggleSnapBtn.textContent=`Snap: ${label}`;
      this.toggleSnapBtn.setAttribute('aria-pressed',String(this.snapEnabled));
    }
    _snapAngle(theta){
      const mode=this._resolveSnapMode();
      if(mode===0) return theta;

      const step=
        mode===1
          ? (TAU/this.sides)
          : (Math.PI/this.sides);

      return Math.round(theta/step)*step;
    }

    _drawFrame(dtSec){
      const ctx=this.ctx,w=this.canvas.clientWidth,h=this.canvas.clientHeight; ctx.fillStyle=this.whiteBg?'#fff':'#000'; ctx.fillRect(0,0,w,h);
      const L=Math.max(0,this.levels|0);
      let drew=false;
      if(this.emergentActive){
        if(!this.emergentPaused && !this.entityLockRotation) this.emergentAngle+=this.rotationSpeed*dtSec*60*(Math.PI/180);
        if(this.entityLockRotation) this.emergentAngle=this.lockedAngle;
        const angle=this._snapAngle(this.emergentAngle);
        if(this.gen.level_tris[L]===null){this._statusMsg("Emergent rotation is disabled in portal-deferred mode for high levels."); return}
        const seed=this.gen.activeSeedTris(), centers=this.gen.activeCenters(); if(!seed||!seed.length) return;
        const rotated=new Array(seed.length);
        for(let i=0;i<seed.length;i++){const tri=seed[i],c=centers[i]; rotated[i]=[rotatePointAround(tri[0],c,angle),rotatePointAround(tri[1],c,angle),rotatePointAround(tri[2],c,angle)]}
        let allTris;
        if(L===0){allTris=rotated}else{const pivot=(L===1)?this.gen.center:this.gen.activePivot(), copies=[rotated]; for(let i=1;i<this.sides;i++){const ang=(TAU/this.sides)*i; copies.push(rotateTrianglesAround(rotated,pivot,ang))} allTris=copies.flat()}
        const fills=this._currentColorArray(allTris), lw=this._lineWidthPx(), stroke=this.edgesOnly?(this.whiteBg?'rgba(0,0,0,1)':'rgba(255,255,255,1)'):null;
        for(let i=0;i<allTris.length;i++) this._drawTriangle(allTris[i],fills[i],stroke,lw);
        this._updateLiveSpectrogram(allTris,dtSec);
        drew=true;
      } else if(this.rotationActive){
        if(this.gen.level_tris[L]===null){
          if(!this.entityLockRotation) this.globalAngle+=this.rotationSpeed*(Math.PI/180);
          else this.globalAngle=this.lockedAngle;
          const angle=this._snapAngle(this.globalAngle);
          const seed=this.gen.activeSeedTris(), pivot=this.gen.activePivot();
          if(seed&&seed.length){ this._drawDeferred(seed,pivot,angle); drew=true; }
        } else {
          if(!this.entityLockRotation) this.globalAngle+=this.rotationSpeed*(Math.PI/180);
          else this.globalAngle=this.lockedAngle;
          const angle=this._snapAngle(this.globalAngle);
          const base=this.gen.activeTriangles(), pivot=this.gen.activePivot(), allTris=rotateTrianglesAround(base,pivot,angle), fills=this._currentColorArray(allTris), lw=this._lineWidthPx(), stroke=this.edgesOnly?(this.whiteBg?'rgba(0,0,0,1)':'rgba(255,255,255,1)'):null;
          for(let i=0;i<allTris.length;i++) this._drawTriangle(allTris[i],fills[i],stroke,lw);
          drew=true;
        }
      } else {
        const base=this.gen.activeTriangles();
        const lockedAngle=this.entityLockRotation ? this._snapAngle(this.lockedAngle) : 0;
        if(base&&base.length){
          const allTris=lockedAngle ? rotateTrianglesAround(base,this.gen.activePivot(),lockedAngle) : base;
          const fills=this._currentColorArray(allTris), lw=this._lineWidthPx(), stroke=this.edgesOnly?(this.whiteBg?'rgba(0,0,0,1)':'rgba(255,255,255,1)'):null;
          for(let i=0;i<allTris.length;i++) this._drawTriangle(allTris[i],fills[i],stroke,lw);
          drew=true;
        } else {
          const seed=this.gen.activeSeedTris(), pivot=this.gen.activePivot();
          if(seed&&seed.length){
            this._drawDeferred(seed,pivot,lockedAngle);
            drew=true;
          }
        }
      }
      if(drew&&this.entityFocusActive&&this.primaryView!=="omega-level"){
        this._drawEntityFFTOverlay(this.activeEntityK);
      }
      this._drawLiveSpectrogramHUD();
      this._updateAudioTick();
      this._drawWaveformPanel();
    }

    _trianglesExtent(tris){if(!tris||!tris.length)return null; let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity; for(const t of tris){for(const p of t){if(p[0]<xmin)xmin=p[0]; if(p[0]>xmax)xmax=p[0]; if(p[1]<ymin)ymin=p[1]; if(p[1]>ymax)ymax=p[1]}} return [xmin,xmax,ymin,ymax]}
    _zoomToDesignExtent(){const tris=this.gen.activeTriangles(), ext=this._trianglesExtent(tris); if(!ext){this._centerCanvas();return} const [xmin,xmax,ymin,ymax]=ext, mx=(xmax-xmin)*.10, my=(ymax-ymin)*.10; this._zoomToRect([xmin-mx,ymin-my,xmax+mx,ymax+my])}
    _centerCanvas(){this.scale=1; this.tx=this.canvas.clientWidth/2; this.ty=this.canvas.clientHeight/2}
    _computeZoomTarget([xmin,ymin,xmax,ymax]){
      const wpx=this.canvas.clientWidth,hpx=this.canvas.clientHeight, ww=(xmax-xmin), wh=(ymax-ymin);
      if(!(ww>0&&wh>0)) return null;
      const sx=(wpx*.85)/(ww*200), sy=(hpx*.85)/(wh*200);
      const scale=Math.min(sx,sy);
      const cx=(xmin+xmax)/2, cy=(ymin+ymax)/2;
      const tx=wpx/2 - cx*(200*scale);
      const ty=hpx/2 + cy*(200*scale);
      return {scale,tx,ty};
    }
    _zoomToRect(rect){
      const target=this._computeZoomTarget(rect);
      if(!target) return;
      this.scale=target.scale;
      this.tx=target.tx;
      this.ty=target.ty;
    }
    _animateZoomToRect(rect,durationMs=400,onDone){
      const startScale=this.scale;
      const startTx=this.tx;
      const startTy=this.ty;

      this._zoomToRect(rect);
      const targetScale=this.scale;
      const targetTx=this.tx;
      const targetTy=this.ty;

      this.scale=startScale;
      this.tx=startTx;
      this.ty=startTy;

      const t0=performance.now();
      const ease=(t)=>t*t*(3-2*t);

      const step=(now)=>{
        const u=clamp((now-t0)/durationMs,0,1);
        const e=ease(u);

        this.scale=startScale+(targetScale-startScale)*e;
        this.tx=startTx+(targetTx-startTx)*e;
        this.ty=startTy+(targetTy-startTy)*e;

        this._render();
        if(u<1) requestAnimationFrame(step);
        else {
          if(typeof onDone==="function") onDone();
          this._refreshAudioParams();
        }
      };

      requestAnimationFrame(step);
    }

    _portalRectForEntity(k,rNear,rFar,padFactor={radial:0.08,tangential:0.2}){
      const n=this.sides;
      const pivot=this.gen.activePivot();
      const theta0=canonicalStartAngle(n);
      const dTheta=TAU/n;
      const kk=((k%n)+n)%n;
      const a0=theta0+kk*dTheta;
      const a1=a0+dTheta;
      const polar=(a,r)=>[pivot[0]+Math.cos(a)*r, pivot[1]+Math.sin(a)*r];
      const pts=[polar(a0,rNear),polar(a1,rNear),polar(a0,rFar),polar(a1,rFar)];
      let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
      for(const [x,y] of pts){if(x<xmin)xmin=x; if(x>xmax)xmax=x; if(y<ymin)ymin=y; if(y>ymax)ymax=y;}
      const thetaC=a0+dTheta/2;
      const radial=[Math.cos(thetaC),Math.sin(thetaC)];
      const tangential=[-radial[1],radial[0]];
      const tangentialSpan=Math.max(1e-6,2*rFar*Math.sin(dTheta/2));
      const radialSpan=Math.max(1e-6,rFar-rNear);
      const radialPad=radialSpan*(padFactor?.radial??0.08);
      const tangentialPad=tangentialSpan*(padFactor?.tangential??0.2);
      const padX=Math.abs(radial[0])*radialPad+Math.abs(tangential[0])*tangentialPad;
      const padY=Math.abs(radial[1])*radialPad+Math.abs(tangential[1])*tangentialPad;
      return [xmin-padX,ymin-padY,xmax+padX,ymax+padY];
    }

    _startEntityRevealTour(k,rNear,rFar){
      if(!isFinite(rNear)||!isFinite(rFar)||!(rFar>0)) return;
      this._stopEntityRevealTour();
      const start=performance.now();
      const duration=this.entityRevealDurationMs;
      const ease=(t)=>t*t*(3-2*t);
      this.entityRevealActive=true;
      const step=(now)=>{
        if(!this.entityRevealActive) return;
        const u=clamp((now-start)/duration,0,1);
        const e=ease(u);
        const r=rNear+(rFar-rNear)*e;
        const bandNear=Math.max(0.0005,r*0.98);
        const bandFar=Math.max(bandNear+0.0005,r);
        const rect=this._portalRectForEntity(k,bandNear,bandFar,{radial:0.04,tangential:0.22});
        const target=this._computeZoomTarget(rect);
        if(target){
          const panWeight=0.35;
          const scaleWeight=0.18;
          this.scale+= (target.scale-this.scale)*scaleWeight;
          this.tx+= (target.tx-this.tx)*panWeight;
          this.ty+= (target.ty-this.ty)*panWeight;
          this._render();
        }
        if(u<1){
          this.entityRevealRequest=requestAnimationFrame(step);
        } else {
          this.entityRevealActive=false;
        }
      };
      this.entityRevealRequest=requestAnimationFrame(step);
    }
    _stopEntityRevealTour(){
      if(this.entityRevealRequest){
        cancelAnimationFrame(this.entityRevealRequest);
        this.entityRevealRequest=null;
      }
      this.entityRevealActive=false;
    }

    _updateHeaderLabels(){
      const n=this.sides, L=this.levels, levelCode=`O${n}CC`;
      this.codeLabel.textContent = (L>1)?`${levelCode}xx${L}`:levelCode;
      const Ltris=this.gen.activeTriangles(), statsTris=(Ltris&&Ltris.length)?Ltris:(this.gen.activeSeedTris()||[]);
      const {nodes,edges}=this._computeGraphStats(statsTris); this.graphStats.textContent=`nodes: ${nodes} | adj: ${edges}`;
    }
    _computeGraphStats(tris){
      if(!tris||!tris.length) return {nodes:0,edges:0};
      const key=(p)=>`${p[0].toFixed(6)},${p[1].toFixed(6)}`, nodeId=new Map(); let nextId=0; const edgeSet=new Set();
      for(const t of tris){const ids=t.map(pt=>{const k=key(pt); if(!nodeId.has(k)) nodeId.set(k,nextId++); return nodeId.get(k)}); const add=(a,b)=>{const[i,j]=a<b?[a,b]:[b,a]; edgeSet.add(`${i}-${j}`)}; add(ids[0],ids[1]); add(ids[1],ids[2]); add(ids[2],ids[0])}
      return {nodes:nodeId.size, edges:edgeSet.size};
    }
    _statusMsg(msg){this.statusEl.textContent=msg}
    _updateStatus(){
      const fpsStr=(this.rotationActive||this.emergentActive)?` | ${this.fps.toFixed(0)} FPS`:'';
      const warningActive=this._hudWarning&&this._hudWarning.expires>performance.now();
      const warningStr=warningActive?` | ⚠ ${this._hudWarning.msg}`:'';
      this._statusMsg(`Sides: ${this.sides} | Levels: ${this.levels} | Alpha: ${this.alpha.toFixed(3)} | Rotation Speed: ${this.rotationSpeed.toFixed(3)}${fpsStr}${warningStr}`);
    }
    _loop(){
      requestAnimationFrame((t)=>this._loop(t));
      const now=performance.now(), dt=Math.max(1,now-this._lastFrameTs);
      this._lastFrameTs=now;
      const dtSec=dt/1000;
      this.analysisTick(dtSec);
      if(this.rotationActive||this.emergentActive){
        this._drawFrame(dtSec);
        this.fps=1000/dt;
        this._updateStatus();
      } else if(!this._drawnOnce){
        this._drawFrame(0);
        this._drawnOnce=true;
      }
      this._renderSpectrogramPanel(dtSec);
    }
    _exposeFingerprintApi(){
      window.computeEntityFingerprint=(k)=>this.computeEntityFingerprint(k);
      window.compareFingerprints=(f1,f2)=>this.compareFingerprints(f1,f2);
      window.computeEntityTimeSignal=(k,opts)=>this.computeEntityTimeSignal(k,opts);
    }
  }

  class AudioEngine {
    constructor(){
      this.ctx=null;
      this.node=null;
      this.ready=false;
      this.enabled=false;

      this.minFreq=40;
      this.freqStep=12;

      this.lastMag=null;
      this.lastFreqs=[];
      this.lastAmps=[];
    }

    async init(){
      if(this.ctx) return;
      const Ctx=window.AudioContext||window.webkitAudioContext;
      if(!Ctx) return;
      const ctx=new Ctx();
      this.ctx=ctx;
      await ctx.audioWorklet.addModule('hlsf-audio-processor.js');
      const node=new AudioWorkletNode(ctx,'hlsf-audio-processor');
      node.connect(ctx.destination);
      this.node=node;
      this.ready=true;
      this._postParams({
        enabled:this.enabled,
        freqs:this.lastFreqs,
        amps:this.lastAmps
      });
    }

    async resume(){
      if(!this.ctx) return;
      if(this.ctx.state==="suspended") await this.ctx.resume().catch(()=>{});
    }

    _postParams({enabled,freqs,amps}){
      if(!this.node) return;
      this.node.port.postMessage({
        type:'params',
        enabled,
        freqs,
        amps
      });
    }

    setEnabled(on){
      if(!this.ctx || !this.node) return;
      this.enabled=!!on;
      this._postParams({
        enabled:this.enabled,
        freqs:this.lastFreqs,
        amps:this.lastAmps
      });
    }

    updateFromMagnitude(mag){
      if(!this.ctx || !this.node || !this.enabled){ this.lastMag=mag; return; }
      if(!mag || !mag.length) return;

      let mx=0;
      const freqs=[];
      const amps=[];

      for(let i=1;i<mag.length;i++){
        const v=Math.max(0,mag[i]);
        if(v<0.01) continue;
        mx=Math.max(mx,v);
        freqs.push(this.minFreq + i*this.freqStep);
        amps.push(v);
      }

      if(!amps.length){
        this.lastFreqs=[];
        this.lastAmps=[];
        this._postParams({
          enabled:false,
          freqs:[],
          amps:[]
        });
        this.lastMag=mag;
        return;
      }

      const denom=mx>0?mx:1;
      for(let i=0;i<amps.length;i++){
        amps[i]=amps[i]/denom;
      }

      this.lastFreqs=[...freqs];
      this.lastAmps=[...amps];
      this._postParams({
        enabled:true,
        freqs:this.lastFreqs,
        amps:this.lastAmps
      });

      this.lastMag=mag;
    }
  }

  const startApp=()=>new App();
  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded",startApp,{once:true});
  }else{
    startApp();
  }
})();
</script>
</body>
</html>
